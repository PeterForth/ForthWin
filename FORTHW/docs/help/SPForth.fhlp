( Справка по особенностям SP-FORTH от стандарта  )
( А также русские эквиваленты стандартных слов   )

*** 

FORTH - Язык среднего уровня и интерактивная среда разработки.
Нашел широкое применение в науке, робототехнике, управлении
оборудованием, обработке образов и искусственном интеллекте.
Позволяет создавать очень компактные и быстрые программы.

Попробуйте набрать HELP HELP
а также TOPIC и HELP TOPIC

*** {{
( "name" -- )

 Взять из входного потока и выполнить "name".
 Если это VOCABULARY сделать содержащийся в нем
 wordlist первым в порядке поиска.
 Если это слово, возвращающее wordlist на стеке данных,
 сделать данный wordlist первым в порядке поиска.

 file:  compiler\spf_modules.f
 forth:  спф 4.0 и выше

 IMMEDIATE слово.

*** }}
( -- )
>: }} PREVIOUS ; IMMEDIATE

*** HELP
( "name" -- )
  Подключает файл help.fhlp, ищется и печатается справочная
  документация к слову "name".
( -- )
  Общие сведения о форте.

  Поиск происходит по умолчанию в файлах
  docs\help\ANSFth94.fhlp
  docs\help\SPForth.fhlp

  Если ничего не найдено, слово преобразуется в верхний
  регистр и ищется снова. Так что можно писать help help.
  Но, скорость поиска при это замедляется в 2 раза! Поэтому
  целесообразно писать слово так, как оно выглядит.
  Синтаксис help help для ленивых людей с мощными компьютерами (it's me :)
  Вы можете создавать и подключать справку к своим
  собственным библиотекам.

  file: lib\ext\help.f
  forth: спф 4.0 и выше

*** EXTRA-MEM

( -- addr )

   VARIABLE переменная, изначально содержит 16384.
   При создании хипа функцией CREATE-HEAP общий размер
   хипа равен: USER-OFFS + EXTRA-MEM + 4
   Возможно перед сохранением записать в EXTRA-MEM 0.
   Эта переменная нужна как буфер для USER переменных, которые
   возможно будут работать на этапе подключения форт текста.

   file: win\spf_win_memory.f
   forth: спф 4.0 и выше

*** USER
( "name" -- )

  Создает переменную аналогично VARIABLE, но эта переменная создается
  динамически при запуске форт системы и инициализируется нулем.
  Сделано для поддержки многопоточности ядром. У кажого потока свои
  копии USER переменных.
  В сп-форте для каждого потока создается
  _отдельный_ хип (и именно из него выделяется блок для USER vars).
  И ALLOCATE выделяет память из локального хипа потока. Соответственно
  автоматически освобождается при завершении потока (если этот поток
  завершается сам, а не убивается другим потоком по STOP).

  file: compiler\spf_defwords.f
  forth: спф 3.75 и выше

*** USER-OFFS
( -- addr )

   VARIABLE переменная, содержит текущее смещение в области данных потока, 
   где создаются USER переменные.

   file: win\spf_win_memory.f
   forth: спф 3.75 и выше

*** IF

 IF...ELSE...THEN
 Условие IF...ELSE...THEN.

( flag --> )
 Параметры
 flag
 если flag <> 0 , то выполнить все слова, которые нахдятся в промежетке
 IF ...THEN, кроме слов в промежутке ELSE ...THEN (если слово ELSE вообще
 используется в условии).

 если flag = 0, то пропустить все слова в диапозоне IF...THEN и выполнить
 первое слово после слова THEN, если внутри ветви находится слово ELSE
 (IF...ELSE...THEN), то выполнить все слова в промежутке ELSE...THEN.
 Заметки
 IF...ELSE...THEN

 Рассмотрим пример слова /, которое берёт со стека два числа и делит
 первое на второе и выводит на экран результат деления, но если
 делитель =0 (что соответственно противоречит законам математики),
 то слово выводит на экран сообщение "Ошибка деления..." и выводит
 на экран результат деления = 0.
>
> : / ( x1 x2 --> )
>   DUP       \ дублирую делитель   ( x1 x2 x2 )
>   0=        \ сравниваю его с 0   ( x1 x2 flag )
>   IF        \ если делитель = 0
>      2DROP  \ , то удаляю со стека 2 числа
>      0      \ осталяю на вершине стека 0
>      ." Ошибка деления..."   \ вывожу сообщение об ошибке
>             \ пропускаю слова в промежутке ELSE ... THEN и перехожу к слову .
>   ELSE      \ иначе, если делитель не равен 0
>      /      \ , то выполняю деление и на стеке остаётся результат деления
>   THEN
>      ." результат=" .  \ вывожу сообщение "результат=" и частное от деления
> ;

 Условие может содержать альтернативную ветвь ELSE, но можно пользоваться
 и без неё, если нужно обработать только одно условие.


 Например:

>
> : ЖАРКО? ( t --> )
> \ слово выводит предупреждение на консоль если температура t превысит 80 С.
>    80 >     ( flag )
>    IF    \ если температура превышает 80 C
>      ." ОПАСНО ! Уменьшите нагрев!"   \ вывести предупреждение на экран
>    THEN
> ;

 Имеется возможность помещать оператор IF...THEN (или IF ... ELSE ... THEN)
 внутрь другого оператора IF...THEN. Фактически можно использовать
 неограниченную вложенность условий друг в друга.

 Все условия являются совокупностью вложенных IF...THEN. Они вложены друг
 в друга, как матрёшки. Три слова IF соответстуют трём словам THEN.
 
$   IF----------------|
$   IF---------|      |
$   IF--|      |      |
$      THEN   THEN   THEN

 ПОМНИТЕ ! Что каждому слову IF должно соответствовать своё THEN, причём
 в пределах одного и того же определения.

 Например:

>
>  IF
>   ...
>    IF
>      ...
>        IF
>          ...
>        THEN
>     THEN
>  THEN

 Основненое применение условий - проверка значений, которые оставляют
 операции сравнения =, <>, <, >, 0= и т.д.

*** +LOOP
*** ?DO
*** DO
*** LOOP
*** (+LOOP)
*** (?DO)
*** (DO)
*** (LOOP)
*** UNLOOP

Цикл со счетчиком вида
>
> ВерхняяГраница НачальноеЗначение DO ... LOOP
реализуется с помощью кода вида
$ (DO) [ссылка_на_Адрес2]  ....  (LOOP)
$     ^                                ^
$     |                                |
$     Адрес1                           Адрес2

использует стек возвратов для хранения вспомогательной информации.

На стеке возвратов (специфично для спф систем) -
$   Адрес1
$   ВерхняяГраница+0x80000000
$   НачальноеЗначение-(ВерхняяГраница+0x80000000)
$   (--вершина стека--)

*** ,"
&unstandard ," "запятая-кавычка" Compat

( "ccc<">" -- )

Выбрать из входного потока строку, ограниченную кавычкой, и уложить ее в шитый
код в формате строки со счетчиком. Выравнять указатель словаря на границу
токена функции (требования те же, что и для ячейки).

*** OK
Печатает "подсказку": текст "ok" и верхние элементы стека. Вызывается
интерпретатором при интерпретации текста с консоли.

Векторное слово, по умолчанию вызывается OK1.

***g: RunTime
*** ?BRANCH
&unstandard ?BRANCH "вопрос-бранч" Compat

( true -- ) ( I: ip[codeAddr] -- ip+ )
( false -- ) ( I: ip[codeAddr] -- codeAddr )

 Код: ?BRANCH [ссылкаНаКод]

 Если на стеке ненулевое значение, ссылка, находящаеся за словом ?BRANCH,
 пропускается. Если на стеке нулевое значение, выполняется переход.
 Используется для реализации операторов IF и WHILE

*** SEE
( "name" -- )

  Вывести машинный код слова name

  file: lib\ext\disasm.f
  forth: spf3.16 и выше

*** MODULE:
( "name" -- )

  start a forth module
  Если такой модуль уже существует, продолжить компиляцию в него.
  Если нет, создать. Установить первый wordlist поиска wordlist
  модуля. А также установить CURRENT.
  В настоящее время частным случаем модуля является VOCABULARY.

See: EXPORT ;MODULE DEFINITIONS

  file: compiler\spf_modules.f
  forth: спф 4.0 и выше

*** EXPORT
( wid -- wid )

   Начать компиляцию во внешний словарь по отношению
   к данному модулю. Обязательно использовать только в пределах
   модуля.

   file: compiler\spf_modules.f
   forth: спф 4.0 и выше

See: MODULE: ;MODULE

*** ;MODULE
( wid -- )
   Закончить определение модуля, снять верхний wordlist поиска,
   установить CURRENT в wid (это CURRENT перед компиляцией модуля)


*** MODULE:
*** EXPORT
*** ;MODULE
  пример использования:
>
> MODULE: xxx
>...
>;MODULE

 ======= или
>
>MODULE: xxx
>...
>EXPORT
>...  \ Эти слова будут компилироваться во внешний по
>     \ отношению к данному модулю
>;MODULE

 ====== или
>
>VOCABULARY xxx \ так можно, потому что VOCABULARY это частный (!)
>               \ случай модуля
>
>: test xxx PROCESS-IN-XXX ;
>
>MODULE: xxx \ здесь в уже созданный ххх будет компилить...
>...
>;MODULE

 ====== или
>
>MODULE: xxx
>...
>EXPORT
>...
>DEFINITIONS
>...
>EXPORT
>...
>DEFINITIONS
>...
>;MODULE

*** ~ruvim
   Ruvim Pinka          ruvim@forth.org.ru
*** ~boa
   Bordachev Andrej     glareboa@mail.ru
*** ~day
   Dmitry Yakimov       ftech@tula.net
*** ~micro
   Dmitry Zyryanov      micro@forth.org.ru
*** ~1001
   Konstantin Tarasov   const@penza.com.ru
*** ~ac
   Andrey Cherezov      andrey@cherezov.koenig.su
*** ~nemnick
   Nicholas Nemtsev     nn@vdk.psc.ru
*** ~mak
   Michael Maximov      mak@mail.rtc.neva.ru
*** ~yz
   Yuriy Zhilovets      yz@nightmail.ru
*** ~mlg
   Michael Gassanenko   mlg@forth.org
*** ~oleg_sh
   Oleg Shalyopa
*** ~trasher
   Dmitry Bobrik


*** AT-THREAD-STARTING
*** AT-PROCESS-STARTING
*** AT-THREAD-FINISHING
*** AT-PROCESS-FINISHING

  Слова, созданные по технологии Scattered Colon Definition by ~mlg
  Использование:
  Например - необходимо чтобы каждый раз при запуске форт системы
  печаталась цифра 2:

>..: AT-PROCESS-STARTING 2 . ;..
  если еще раз:
>..: AT-PROCESS-STARTING 2 . ;..
  то будет печататься уже две двойки.

  ..: и ;.. - специальные слова форт системы.

*** spf4.ini
   Файл, который подключается при запуске форт системы словом
   SPF-INI. Подключается простым INCLUDE-PROBE

*** STARTLOG
   Начать лог ввода/вывода. Если лог уже открыт, очистить и начать заново

   Создаёт файл spf.log и записывает его хэндл в H-STDLOG.

*** ENDLOG 
   Закончить запись в лог-файл.

*** TO-LOG
( a u -- )
   Записать строку в лог-файл. Вызывается в дефолтных векторах для TYPE и ACCEPT

*** .TO-LOG
( n -- )
   Записать число в лог-файл.

*** H-STDLOG
   Хэндл лог-файла.

*** spf.log
   Лог файл форт системы. 

See: STARTLOG ENDLOG TO-LOG H-STDLOG

*** \EOF
( -- )
   Прекращает трансляцию текущего файла. Аналог
   SOURCE-ID FILE-SIZE THROW SOURCE-ID REPOSITION-FILE ...
   только более короткий.

   file: compiler\spf_translate.f
   forth: spf 4.0 и выше

*** TIMER@
( -- tlo thi )

  Возвращает значение таймера процессора (команда RTDSC)
  (только для процессоров Intel Pentium совместимых).
  Число тактов процессора за прошедшее время.
  Возвращаемое значение зависит от частоты процессора.

  file: spf_forthproc.f
  forth: spf 4.0 и выше

*** NOTFOUND
( addr u -- i*x )
  
  Если INTERPRET не находит слово в контексте поиска, оно
  ищет NOTFOUND в текущем контексте поиска и
  вызывает NOTFOUND с этим словом как параметром.
  Может быть определено как:

> : NOTFOUND ?SLITERAL ;

  Но также еще поддерживается синтаксис:
  <vocabulary>::<word>

  Слово NOTFOUND может делать с литералом что угодно (вместо SLITERAL?)
  Например:
>
>  5 5 + .
>  10  Ok
>  : NOTFOUND ." =" TYPE ." = " ;
>   Ok
>  5 5
>  =5= =5=  Ok

See: ::

  file: compiler\spf_translate.f
  forth: spf 4.0 и выше

*** ::

  Синтаксис доступа к словам в словарях.
  <vocabulary>::<word>
  Или
  <vocabulary1>::<vocabulary1>::<vocabulary1>::<word>

  Поддерживаются как режим компиляции, так и интерпретации.
  Причем все слова кроме последнего после :: исполняются (!)
  вне зависимости от состояния STATE.
  Перед <word> может быть пробел, например: <vocabulary>:: <word>
  Это для ситуаций типа:

>: DO-SMTH::  PROCESS-SMTH S" Voc1::" EVALUATE-WITH ;
>
>DO-SMTH:: SOME-WORD

  file: compiler\spf_translate.f
  forth: spf 4.0 и выше

See: EVALUATE-WITH

*** EVALUATE-WITH
( i*x c-addr u xt -- j*x )

   Считая c-addr u входным потоком, вычислить её интерпретатором xt.
   Например:
>
>: SVARIABLE ( addr u )
>       ['] VARIABLE EVALUATE-WITH
>;

See: EVAL-WORD EVALUATE

  file: compiler\spf_translate.f
  forth: spf 4.0 и выше

*** EVAL-WORD
( c-addr u -- )

   Интерпретировать ( транслировать) слово с именем  c-addr u

See: EVALUATE-WITH EVALUATE

  file: compiler\spf_translate.f
  forth: spf 4.0 и выше

*** TERMINATE
( -- )

   Уничтожить текущий поток и его хип.

  file: win\spf_win_mtask.f
  forth: spf 4.0 и выше

*** TOPIC
( -- )
  Отображение содержания справки
( "name" -- )
  Отображения содержимого "name" пункта содержания (это может
  быть список слов на данную тему например).

*** FILE-EXIST
( a u -- flag )

  Истина если файл с указанным именем существует.

  file: win\spf_win_io.f

*** FIND-FULLNAME
( a u -- a1 u1 )

  Найти файл и вернуть его полный путь. По умолчанию файл ищется в текущем каталоге,
  потом в devel, потом в каталоге с исполняемым файлом spf. Если указанный файл не найден -
  выбрасывается исключение. Это слово - вектор.

  file:compiler\spf_win_translate.f

