<HTML>
<HEAD>
 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
 <STYLE type="text/css">
body {background:white;}
* {font-family: arial, verdana, sans-serif}
code {font-family: 'Lucida Console', 'Courier New', monospace}
pre, code { background : #EEEEF4} </STYLE>
</HEAD>
<BODY>
<div align="center">
<table width="800">
<tr><td align="left">
<p><a id="start"/></p>

<h1>Особенности <a href="readme.ru.html">SPF</a></h1>

<p><title>Особенности SPF</title></p>

<p><i>Краткое вступление для тех, кто уже знаком с какой-либо Форт-системой и
стандартом ANS'94.</i></p>

<p><small>Последнее обновление: $Date: 2008/11/14 20:13:12 $</small></p>

<!-- $Revision: 1.40 $ -->

<hr />

<p>[<a href="intro.ru.html">Русский</a>] [<a href="intro.en.html">Английский</a>]</p>

<hr />

<h2>Содержание</h2>

<ul>
<li><a href="#devel">Установил SPF4. И где здесь что-куда?</a></li>
<li><a href="#include">Как запускать и подключать файлы?</a></li>
<li><a href="#require">REQUIRE</a></li>
<li><a href="#included-path">Пути поиска файлов для INCLUDED</a></li>
<li><a href="#module">Модули</a></li>
<li><a href="#case">Регистро-зависимость</a></li>
<li><a href="#numbers">Ввод чисел</a></li>
<li><a href="#float">Вещественные числа (числа с плавающей точкой)</a></li>
<li><a href="#struct">Структуры</a></li>
<li><a href="#forget">Где FORGET?</a></li>
<li><a href="#not">Где NOT?</a></li>
<li><a href="#defer">Где DEFER?</a></li>
<li><a href="#cls">Как одним словом очистить стек?</a></li>
<li><a href="#comments">Комментарии</a></li>
<li><a href="#string">Строки</a></li>
<li><a href="#task">Многозадачность</a></li>
<li><a href="#voc">Словари</a></li>
<li><a href="#locals">Локальные и временные переменные</a></li>
<li><a href="#save">Генерация исполняемых модулей (exe-файлов)</a></li>
<li><a href="#dll">Подключение dll-библиотек</a></li>
<li><a href="#debug">Средства отладки</a></li>
<li><a href="#opt">Оптимизатор</a></li>
<li><a href="#ans">Поддержка ANS</a></li>
<li><a href="#callback">Callback'и</a></li>
<li><a href="#notfound">Слово NOTFOUND</a></li>
<li><a href="#scatcoln">Scattered colons</a></li>
<li><a href="#doublecolon">Область видимости</a></li>
<li><a href="#catch">Обработка исключений</a></li>
</ul>

<hr />

<p><a id="devel"/></p>

<h3><a href="#devel">Установил SPF4. И где здесь что-куда?</a></h3>

<p>Первое и самое важное - расположение ваших рабочих файлов. В дистрибутиве SPF
есть каталог DEVEL, предназначенный для разработчиков (в том числе и вас).
Создайте в ней ваш подкаталог, например, ~vasya. И теперь вы можете подключать ваши
файлы написав сокращённый путь в виде <code>~vasya/prog/myprog.f</code>. Это упрощает
взаимный доступ к библиотекам и программам. Общепринято библиотеки класть в
подкаталог lib, а примеры программ в prog.</p>

<p>В каталоге DEVEL собраны наработки других SP-Forth'еров, с кратким (очень
кратким) их обзором вы можете ознакомиться в 
<a href="devel.ru.html">SPF_DEVEL</a>, либо пройтись по файлам самому.</p>

<p>В каталоге <code>samples/win/spfwc</code> вы найдёте GUI фронтенд для SPF. Просто
запустите <code>compile.bat</code> и скопируйте полученный бинарный файл <code>spf4wc.exe</code> в
корневой каталог установки (рядом с <code>spf4.exe</code>). </p>

<hr />

<p><a id="include"/></p>

<h3><a href="#include">Как запускать и подключать файлы?</a></h3>

<p>В командной строке скормить файл SPF'у можно просто указав путь к нему в
параметрах запуска, </p>

<pre><code>spf.exe ~vasya/prog/myprog.f
</code></pre>

<p>Заметьте, что путь для включения могут быть как абсолютным, так и
относительно каталога <a href="#devel">devel</a>.</p>

<p>В консоли SPF (в режиме интерпретации) достаточно набрать имя файла:</p>

<pre><code>~vasya/prog/myprog.f
</code></pre>

<p>В целях совместимости лучше подключать явно:</p>

<pre><code>S" ~vasya/prog/myprog.f" INCLUDED
</code></pre>

<p>Но правильнее всего использовать <code>REQUIRE</code>.</p>

<hr />

<p><a id="require"/></p>

<h3><a href="#require">REQUIRE</a></h3>

<p>В SPF есть нестандартное слово <code>REQUIRE ("word" "file" -- )</code>, где <code>word</code> -
некоторое слово определённое в библиотеке <code>file</code>. Если слово <code>word</code> присутствует в 
контекстном словаре, <code>REQUIRE</code> считает, что библиотека уже была подключена и не загружает её.
Так избегается двойная загрузка библиотек.
Если же найти <code>word</code> не удаётся - библиотека подключается обычным образом
(через <code>INCLUDED</code>).
Например:</p>

<pre><code>REQUIRE CreateSocket ~ac/lib/win/winsock/sockets.f
REQUIRE ForEach-Word ~pinka/lib/words.f
REQUIRE ENUM ~nn/lib/enum.f
</code></pre>

<p><strong>NB:</strong> В качестве <code>word</code> выбирайте всегда наиболее уникальное слово из
подключаемой библиотеки.</p>

<hr />

<p><a id="included-path"/></p>

<h3><a href="#included-path">Пути поиска файлов для INCLUDED</a></h3>

<p><code>S" file.f" INCLUDED</code> будет искать в перечисленных ниже местах в именно таком порядке</p>

<ul>
<li>короткое имя файла <code>file.f</code> (т.е. в текущем каталоге)</li>
<li><code>PATH_TO_SPF.EXE/devel/file.f</code> (т.о. удобно использовать чужие наработки), </li>
<li><code>PATH_TO_SPF.EXE/file.f</code> (так подключаются стандартные либы и другие файлы из поставки SPF). </li>
</ul>

<p>Если требуется указать больше путей поиска (например использовать форт код разделяемый между
системами, или неважно - любой код вне дерева каталогов SPF который не может быть адресован
относительно текущего файла), то можно либо переопределить <code>FIND-FULLNAME</code> (который <code>VECT</code>) 
либо использовать внешнюю либу - <code>~ygrek/spf/included.f</code>.</p>

<p><strong>TODO:</strong> Вынести отдельно</p>

<p>Тогда потребуется только прописать в spf4.ini</p>

<pre><code>~ygrek/spf/included.f
with: my_path\
S" my path with spaces/" with
</code></pre>

<p>и все файлы будут искаться в <code>my_path</code> в дополнение к описанному выше алгоритму
(<code>my_path</code> может быть как абсолютным так и относительно spf.exe). </p>

<hr />

<p><a id="module"/></p>

<h3><a href="#module">Модули</a></h3>

<p>В SPF есть модули, которые позволяют скрывать некоторые внутренние слова
библиотек выводя наружу только слова для взаимодействия.</p>

<pre><code>MODULE: vasya-lib
\ внутренние слова
EXPORT
\ слова взаимодействия, видные снаружи, компилируются во внешний словарь.
DEFINITIONS
\ опять внутренние слова
EXPORT
\ ну вы поняли :)
;MODULE
</code></pre>

<p>Код <code>MODULE: vasya-lib</code> можно писать много раз - последующие вызовы будут
докомпилировать слова в тот же модуль. На самом деле слово определённое через
<code>MODULE:</code> это обычный <a href="#voc">словарь</a>.</p>

<hr />

<p><a id="case"/></p>

<h3><a href="#case">Регистро-зависимость</a></h3>

<p>SPF регистрозависим, то есть для него слова <code>CHAR</code> , <code>Char</code> и <code>char</code> - три 
разных слова. Сделать SPF независимым от регистра слова можно подключив файл 
<code>lib/ext/caseins.f</code>. По умолчанию, регистро-независимость включается сразу 
после подключения <code>lib/ext/caseins.f</code>.</p>

<p>Чтобы регистро-независимость временно выключать/включать, используйте 
переменную <code>CASE-INS</code>:</p>

<pre><code>REQUIRE CASE-INS lib/ext/caseins.f
2 dup * .
CASE-INS OFF \ вернуть обратно режим зависимости от регистра
2 DUP * .
CASE-INS ON  \ включить регистро-независимость
2 dup * .
</code></pre>

<hr />

<p><a id="numbers"/></p>

<h3><a href="#numbers">Ввод чисел</a></h3>

<p>SPF позволяет вводить шестнадцатеричные числа вне зависимости от текущей системы
счисления (значения переменной <code>BASE</code>) так:</p>

<pre><code>0x7FFFFFFF
</code></pre>

<p>Если в числе последний символ будет точкой, то оно воспримется как двойное (то 
есть - 64-битное, занимающее две ячейки на стеке):</p>

<pre><code>9999999999. 1. D+ D.
</code></pre>

<hr />

<p><a id="float"/></p>

<h3><a href="#float">Вещественные числа (числа с плавающей точкой)</a></h3>

<p>Подключив либу <code>lib/include/float2.f</code>, можно вводить вещественные числа в 
формате <code>[+|-][dddd][.][dddd]e[+|-][dddd]</code>. То есть главным определителем что число
вещественное, является наличие символа <code>e</code>.</p>

<p>Слова для работы с вещественными числам реализованы согласно стандарта ANS-94:</p>

<pre><code>REQUIRE F. lib/include/float2.f
0.1e 0.2e F+ F.
FVARIABLE a
FPI a F!
a F@ F.
</code></pre>

<p>Для переноса целых двойных значений между стеком данных и float-стеком в 
SPF есть слова <code>D&gt;F ( D: d -- F: f )</code> и <code>F&gt;D ( F: f -- D: d )</code>. При переносе
нецелого значения на стек данных часть после запятой отбрасывается без округления. 
Есть также аналогичные слова для работы с одинарными значениями:</p>

<pre><code>10 DS&gt;F 3 DS&gt;F F+ F&gt;DS .
</code></pre>

<p>Так как для float-стека в SPF используется аппаратный стек сопроцессора, то его
особенности нужно иметь в виду (закольцованность и ограниченность 8-ью ячейками).</p>

<hr />

<p><a id="struct"/></p>

<h3><a href="#struct">Структуры</a></h3>

<p>Структуры в SPF создаются через слово <code>--</code> (оно же <code>FIELD</code>). Пример:</p>

<pre><code>0
CHAR -- flag
CELL -- field
10 CELLS -- arr
CONSTANT struct
</code></pre>

<p>Слова <code>flag</code>, <code>field</code> и <code>arr</code> будут прибавлять к адресу своё смещение 
относительно начала структуры. А в <code>struct</code> записан общий размер
всей структуры. То есть, можно:</p>

<pre><code>struct ALLOCATE THROW VALUE s \ взяли память из кучи под один экземпляр struct
1 s flag С!  10 s field ! \ записали значения в поля структуры
s arr 10 CELLS DUMP \ вывели содержимое массива в структуре
s FREE THROW \ сняли экземпляр struct
</code></pre>

<p>Структуры можно наследовать:</p>

<pre><code>0
CELL -- x
CELL -- y
CONSTANT point \ у point два поля

point
CELL -- radius
CONSTANT circle \ у circle три поля: x, y, radius

point
CELL -- w
CELL -- h
CONSTANT rect \ у rect четыре поля: x, y, w, h
</code></pre>

<hr />

<p><a id="forget"/></p>

<h3><a href="#forget">Где FORGET?</a></h3>

<p><code>FORGET</code> нет. Но есть <code>MARKER ( "name" -- )</code> (в <code>lib/include/core-ext.f</code>).</p>

<hr />

<p><a id="not"/></p>

<h3><a href="#not">Где NOT?</a></h3>

<p>Слова <code>NOT</code> (лог. отрицание) в ядре SPF нет. Его можно добавить расширением
<code>~profit/lib/logic.f</code>. Также там определяются другие слова для работы 
логикой: <code>&gt;=</code> (больше или равно) и <code>&lt;=</code> (меньше или равно).</p>

<hr />

<p><a id="defer"/></p>

<h3><a href="#defer">Где DEFER?</a></h3>

<p>Для создания "векторов" (DEFERred words) в SPF используется слово <code>VECT ( "word" -- )</code>.
Присвоение действия вектору делается словом <code>TO ( xt "word" -- )</code>.</p>

<p>Если вам нужно использовать именно <code>DEFER</code> и <code>IS</code>, то эти слова можно подключить дополнительно 
из файла <code>lib/include/defer.f</code>.</p>

<p>Вариант с размещением ячейки вектора в USER-области потока называется <code>USER-VECT ( "word" -- )</code>.
Обратите внимание: так как вектор порождённый <code>USER-VECT</code> на равных правах со другими переменными 
расположенными в <a href="#task">USER-блоке</a> (<code>USER</code> , <code>USER-VALUE</code>) заполняется нулём (что является 
неправильным <code>xt</code>), то выставить вектор в начальное значение нужно вам (например через <a href="#scatcoln">AT-THREAD-STARTING</a>).</p>

<hr />

<p><a id="cls"/></p>

<h3><a href="#cls">Как одним словом очистить стек?</a></h3>

<p>Наберите <code>lalala</code>. Или <code>bububu</code>. Или <code>лялятополя</code>. Возникнет ошибка и стек сбросится.
На самом деле стек сбросит слово <code>ABORT</code>, которое будет вызвано если интерпретатор
не найдёт введённое слово. Ну а на самом-самом деле - это делается так: <code>S0 @ SP!</code></p>

<hr />

<p><a id="comments"/></p>

<h3><a href="#comments">Комментарии</a></h3>

<p>В SPF есть комментарий до конца строки <code>\</code>. Есть и обычные, скобочные, комментарии,
которые к тому же ещё и многострочные. То есть:</p>

<pre><code>\ комментарий до конца строки
( комментарий
и даже в несколько строк )
</code></pre>

<p>Есть слово <code>\EOF</code> которое делает комментарием всё идущее после него в файле. Таким
образом удобно отделять примеры использования библиотеки от самой библиотеки.</p>

<pre><code>word1 word2
\EOF
комментарий до конца файла
</code></pre>

<p>В <code>SPF/Linux</code> дополнительно есть комментарий <a href="http://en.wikipedia.org/wiki/Shebang_(Unix)"><code>#!</code></a>. Если файл с текстом программы на форте 
сделать исполняемым и дописать в начале строку </p>

<pre><code>#! абсолютный_путь_к_spf
</code></pre>

<p>то можно будет запускать скрипт на исполнение не указывая путь к spf в коммандной строке. 
Коммандная оболочка (shell) сама запустит spf передав путь к файлу скрипта в качестве параметра. 
А интерпретатор SPF первую строчку пропустит как комментарий.</p>

<hr />

<p><a id="string"/></p>

<h3><a href="#string">Строки</a></h3>

<p>В SPF в основном используются строки со счётчиком на стеке - т.е. два значения
<code>(addr u)</code>. Для записи строковых литералов (строковых констант) используется
слово <code>S"</code>, которое в зависимости от текущего режима выполняет несколько разные
действия:</p>

<ul>
<li><p>В режиме интерпретации строка находится во временном текстовом буфере разбора (<code>TIB</code>),
и соответственно, работает только в пределах одной строки.</p></li>
<li><p>В режиме компиляции строка вкомпилируется непосредственно в шитый код определяемого слова.</p></li>
</ul>

<p><strong>NB</strong>: В память после символов строки добавляется один нулевой байт, в
счётчике символов он не учитывается - это сделано для удобства работы с функциями WinAPI.</p>

<p>Слово <code>S"</code> создаёт т. н. статическую строку, она находится или в буфере, или в словарной
структуре SPF. Для работы со динамическими строками, которые резервируются в "куче" и снимаются
оттуда есть библиотека <code>~ac/lib/str5.f</code>. Пример её использования:</p>

<pre><code>REQUIRE STR@ ~ac/lib/str5.f
"" VALUE r \ создаём пустую строку
" мама, мама, " VALUE m
" что я буду делать?" VALUE w
m r S+  w r S+
r STYPE
&gt; мама, мама, что я буду делать?
</code></pre>

<p>Кроме конкатенации строк можно использовать и подстановку (в том числе и других строк):</p>

<pre><code>" 2+2={2 2 +}" STYPE
&gt; 2+2=4
</code></pre>

<p>Исчерпывающее описание и более подробные примеры см. в самой библиотеке.</p>

<p>Надо также заметить что в ядре SPF поддерживается соглашение об именовании слов 
начинающихся с <code>S-</code>, и слов кончающихся <code>-ED</code>.</p>

<p>Префикс <code>S-</code> означает что слово принимает строку с явно заданной длиной (например есть
<code>SFIND</code> в дополнение к стандартному <code>FIND</code>, есть <code>SLITERAL</code> к <code>LITERAL</code>).</p>

<p>Суффикс <code>-ED</code> есть в словах <code>CREATED</code>, <code>INCLUDED</code>, <code>REQUIRED</code>, <code>ALIGNED</code>. Он обозначает что это
слово, в отличие от своего "корня", будет ожидать параметры на стеке, а не выбирать их из
входного потока (или из глобальной переменной, как это происходит в случае с <code>ALIGN</code> и <code>ALIGNED</code>).</p>

<p>Например, стандартный <code>CREATE</code> берёт свой параметр из входного потока, тогда как <code>CREATED</code>
явно забирает параметр со стека данных в виде начала строки и её длины.</p>

<hr />

<p><a id="task"/></p>

<h3><a href="#task">Многозадачность</a></h3>

<p>Потоки создаются словом <code>TASK: ( xt "name" -- )</code> и запускаются словом 
<code>START ( u task -- tid )</code>, 
<code>xt</code> это исполнимый токен который получит управление при старте потока и
на стеке будет пользовательский параметр <code>u</code>. Возвращаемое значение <code>tid</code>
используется для остановки потока снаружи словом <code>STOP ( tid -- )</code>. Слова
<code>SUSPEND ( tid -- )</code> и <code>RESUME ( tid -- )</code> используются для приостановки
исполнения потока "на паузу", и возобновления исполнения (тоже снаружи 
самого потока).</p>

<p>Приостановить текущий поток на заданное время (в миллисекундах) можно 
словом <code>PAUSE ( ms -- )</code>.</p>

<p>Пример:</p>

<pre><code>REQUIRE { lib/ext/locals.f

:NONAME { u \ -- }
   BEGIN
   u .
   u 10 * 100 + PAUSE
  AGAIN
; TASK: thread

: go
  10 0 DO I thread START LOOP
  2000 PAUSE
  ( tid1 tid2 ... tid10 )
  10 0 DO STOP LOOP
;

go
</code></pre>

<p>Обычные переменные (<code>VARIABLE</code>, <code>VALUE</code>) будут разделять своё значение между
потоками. Если же переменная должна быть локальной для потока - следует
определять её словом <code>USER ( "name" -- )</code> или <code>USER-VALUE ( "name" -- )</code>.
USER-переменные при старте потока инициализируются нулём.</p>

<hr />

<p><a id="voc"/></p>

<h3><a href="#voc">Словари</a></h3>

<p>Словари создаются либо стандартным <code>VOCABULARY ( "name" -- )</code> 
либо словом <code>WORDLIST ( -- wid )</code>. 
Точнее, <code>WORDLIST</code> это более общее понятие - просто список слов. Есть
также слово <code>TEMP-WORDLIST ( -- wid )</code> создающее временный словарь, который по
окончании работы надо освободить из памяти словом <code>FREE-WORDLIST</code>, содержимое
временного словаря не попадёт в образ системы при использовании слова <code>SAVE</code>.
Слово <code>{{ ( "name" -- )</code> сделает словарь name контекстным, а слово <code>}}</code> вернёт как
было. Пример:</p>

<pre><code>MODULE: my
: + * ;
;MODULE
{{ my 2 3 + . }}
</code></pre>

<p>напечатает 6, а не 5.</p>

<hr />

<p><a id="locals"/></p>

<h3><a href="#locals">Локальные и временные переменные</a></h3>

<p>Не входят в ядро, но подключаются:</p>

<pre><code>REQUIRE { lib/ext/locals.f

\ пример простого использования
: test { a b | c d }  \ a b инициализируются со стека, c и d нулями
  a TO c
  b TO d
  c . d . ;
1 2 test
&gt;1 2
&gt; Ok
</code></pre>

<p>Подробное описание и примеры использования смотрите в самой библиотеке <code>lib/ext/locals.f</code>.</p>

<p><code>lib/ext/locals.f</code> реализует синтаксис несовместимый со стандартом ANS-94. 
ANS-реализация локальных переменных есть в библиотеке <code>~af/lib/locals-ans.f</code>:</p>

<pre><code>REQUIRE LOCALS| ~af/lib/locals-ans.f

: plus  LOCALS| a b |
a b + TO a
a b * ;
2 3 plus .
&gt;10
&gt; Ok
</code></pre>

<hr />

<p><a id="save"/></p>

<h3><a href="#save">Генерация исполняемых модулей (exe-файлов)</a></h3>

<p>Слово <code>SAVE ( a u -- )</code> сохраняет всю форт-систему, включая все словарные
структуры (кроме временных!) в исполняемый модуль путь к которому задаётся
строкой <code>a u</code>. Точка входа определяется value-переменной <code>&lt;MAIN&gt;</code> для
консольного режима и переменной <code>MAINX</code> для GUI. Режим определяется
value-переменными <code>?CONSOLE</code> и <code>?GUI</code>. <code>SPF-INIT?</code> контролирует интерпретацию
командной строки и подключение spf4.ini:</p>

<pre><code>0 TO SPF-INIT?
' ANSI&gt;OEM TO ANSI&gt;&lt;OEM
TRUE TO ?GUI
' NOOP TO &lt;MAIN&gt;
' run MAINX !
S" gui.exe" SAVE  
</code></pre>

<p>или</p>

<pre><code>' run TO &lt;MAIN&gt;
S" console.exe" SAVE
</code></pre>

<hr />

<p><a id="dll"/></p>

<h3><a href="#dll">Подключение dll-библиотек</a></h3>

<p><strong>FIXME переписать, чтобы было понятней, примеры</strong></p>

<p>Для функций использующих формат вызова stdcall (например Win32 API) :</p>

<pre><code>WINAPI: SevenZip 7-zip32.dll
</code></pre>

<p>Для формата вызова cdecl (например msvcrt.dll) и функций с переменным числом
параметров используйте :</p>

<pre><code>REQUIRE CAPI: ~af/lib/c/capi.f
2 CAPI: strstr msvcrt.dll
</code></pre>

<p>Если нужно подключить все функции из dll-файла то можно использовать для
stdcall :</p>

<pre><code>REQUIRE UseDLL ~nn/lib/usedll.f
UseDLL "имя_библиотеки"
</code></pre>

<p>или:</p>

<pre><code>REQUIRE DLL ~ac/lib/ns/dll-xt.f
DLL NEW: "имя_библиотеки" 
</code></pre>

<p>Для cdecl :</p>

<pre><code>REQUIRE USES_C ~af/lib/c/capi-func.f
USES_C "имя_библиотеки"
</code></pre>

<p>или:</p>

<pre><code>REQUIRE SO ~ac/lib/ns/so-xt.f
SO NEW: "имя_библиотеки"
</code></pre>

<p><strong>SPF/linux</strong></p>

<p>Низкоуровневые слова <code>DLOPEN</code> <code>DLSYM</code> <code>symbol-addr</code> <code>symbol-call</code></p>

<p>Использование. По-умолчанию подключены <code>libc</code> <code>libdl</code> и <code>libpthread</code>.
Подключение дополнительных библиотек :</p>

<pre><code>USE имя_so_файла
</code></pre>

<p>Вызов функции</p>

<pre><code>(( H-STDOUT S" hello world!" )) write DROP
</code></pre>

<p>Обратите внимание, параметры передаются слева направо, а после вызова <code>DROP</code> убирает возвращаемое
значение. Если на стеке уже есть часть параметров -- можно писать так :</p>

<pre><code>H-STDOUT 1 &lt;( S" hello world!" )) write DROP
</code></pre>

<p>т.е. число перед <code>&lt;(</code> указывает сколько параметров внешней функции находится на стеке "за скобками".</p>

<p>Реализация <code>(( ))</code> в ядре не позволяет делать вложенные вызовы. Для обхода этого ограничения
используйте <code>~ygrek/lib/linux/ffi.f</code>.</p>

<p>В spf/linux работает также <code>~ac/lib/ns/so-xt.f</code> (абсолютно точно так же как в Windows!).</p>

<hr />

<p><a id="debug"/></p>

<h3><a href="#debug">Средства отладки</a></h3>

<p>Слово <code>STARTLOG</code> включает запись всего консольного вывода (<code>TYPE</code>, <code>.</code> -- любые 
слова, выводящие в stdout) в лог-файл <code>spf.log</code> в текущем каталоге. <code>ENDLOG</code> 
соответственно выключает такое поведение.</p>

<p><a href="devel.ru.html#debug">Больше средств в devel</a></p>

<hr />

<p><a id="opt"/></p>

<h3><a href="#opt">Оптимизатор</a></h3>

<p>SPF - форт-система с подпрограммным шитым кодом, то есть компиляция проходит
сразу в исполняемый код в виде цепочек <code>CALL &lt;адрес-cfa-слова&gt;</code>. Этот код можно
запускать и непосредственно, но в системе по-умолчанию есть ещё и оптимизатор, 
который обрабатывает машкод для большего быстродействия, выполняя
inline-подстановку и peephole-оптимизацию. Подробнее на ForthWiki:
"<a href="http://wiki.forth.org.ru/оптимизирующий%20компилятор">Оптимизирующий компилятор</a>".</p>

<p><strong>Управление оптимизатором</strong> <em>(значения по умолчанию работают в подавляющем
большинстве случаев, вам скорее всего не нужны эти опции!)</em></p>

<ul>
<li><code>DIS-OPT</code> отключает макрооптимизацию</li>
<li><code>SET-OPT</code> включает макрооптимизацию (по-умолчанию включена)</li>
<li><code>0 TO MM_SIZE</code> отключает inline подстановку оптимизатора (помните что inline
подстановка для <code>DO</code> <code>LOOP</code> и некоторый других слов выполняется ядром spf и не зависит от этой опции)</li>
<li><code>TRUE TO ?C-JMP</code> включает оптимизацию хвостовой рекурсии (экспериментальная,
по-умолчанию выключена, иногда глючит)</li>
<li><code>FALSE TO VECT-INLINE?</code> отключает прямую компиляцию векторных вызовов.</li>
</ul>

<p><strong>NB</strong>: Если вдруг ваша программа начинает выкидывать неожиданные фортели -
отключите временно оптимизацию словом <code>DIS-OPT</code>, есть вероятность (очень
маленькая!), что это может быть ошибка в оптимизаторе. Если это так -
локализуйте её и напишите пожалуйста багрепорт.</p>

<p>Результат компиляции слова в виде машинного кода можно посмотреть вручную с
помощью дизассемблера:</p>

<pre><code>REQUIRE SEE lib/ext/disasm.f
SEE слово
</code></pre>

<p>или получить построчный листинг (форт-код и соответствующий машкод)</p>

<pre><code>REQUIRE INCLUDED_L ~mak/listing2.f
S" файл, машкод которого хотим посмотреть"  INCLUDED_L
\ листинг будет лежать рядом с подключаемым файлом
</code></pre>

<p><strong>Оптимизация условных переходов</strong></p>

<p>Например типичная комбинация <code>10 &gt; IF ... THEN</code> падает не в последовательность действий:
укладка на стек литерала 10, сравнение двух верхних значений и запись результата на стек 
и затем проверку флага с условным переходом; а в две машинные команды:</p>

<pre><code>lib/ext/disasm.f
:NONAME DUP 10 &gt; IF 1 . THEN ; REST
</code></pre>

<p>Вывод:</p>

<pre><code>cmp eax, # A
jle @@1
...
@@1:
</code></pre>

<p>Похожим образом обрабатываются другие типичные комбинации <code>2DUP = IF ... THEN</code> и им подобные:</p>

<pre><code>lib/ext/disasm.f
:NONAME 2DUP = IF 1 . THEN ; REST
</code></pre>

<p>Вывод:</p>

<pre><code>cmp eax, 0 [ebp]
jne @@1
...
@@1:
</code></pre>

<p>Оптимизируются последовательности логических операций (<code>0=</code> здесь аналогичен отрицанию, поэтому 
последовательность <code>0&lt; 0=</code> означает "больше или равно нулю"):</p>

<pre><code>lib/ext/disasm.f
:NONAME DUP 0&lt; 0= IF 1 . THEN ; REST
</code></pre>

<p>Вывод:</p>

<pre><code>or eax, eax
jl @@1
...
@@1:
</code></pre>

<p><strong>Компиляция слов порождаемых словами <code>CREATE</code>, <code>VARIABLE</code>, <code>VALUE</code>, <code>USER</code></strong></p>

<p>При компиляции переменных или констант, вместо записи простого вызова DOES-действия 
порождённого слова, запускается процедура специальной обработки которая разворачивает 
вызов в аналогичную последовательность машинного кода. Например:</p>

<pre><code>lib/ext/disasm.f
10 CONSTANT c
:NONAME c ; REST

10 VALUE vl
:NONAME vl ; REST

VARIABLE vr
:NONAME vr @ ; REST
</code></pre>

<p>Вывод:</p>

<pre><code>mov     -4 [ebp] , eax
mov     eax , # A
lea     ebp , -4 [ebp}
ret

mov     -4 [ebp] , eax
mov     eax , 572410  ( vl+5  )
lea     ebp , -4 [ebp]
ret

mov     -4 [ebp] , eax
mov     eax , 57243C  ( vr+5  )
lea     ebp , -4 [ebp]
ret
</code></pre>

<hr />

<p><a id="ans"/></p>

<h3><a href="#ans">Поддержка ANS</a></h3>

<p>Максимального соответствия ANS'94 можно добиться подключив
<code>lib/include/ansi.f</code>. Там определяются дополнительные наборы слов, некоторые
заглушки и т. д.</p>

<p>Также исправляется нарушающая стандарт оптимизация слов из ядра для 
работы с файлами - <code>OPEN-FILE</code>, <code>CREATE-FILE</code> и другие неявно 
требуют строку оканчивающуюся нулём, тогда как стандарт этого не 
требует. <code>lib/include/ansi-file.f</code> при получении строки без нуля в конце 
самостоятельно добавляет нулевой байт. При этом имя файла копируется во 
временный динамический буфер, который остаётся неосвобожденным для последующего 
использования. При явном указании имени файла с помощью строчных литералов <code>S"</code>
и строчных библиотек <code>~ac/lib/str*.f</code> необходимости в этом исправлении нет, 
т.к. строки всегда заканчиваются нулем. Но при использовании не-SPF-библиотек 
это может пригодиться.</p>

<hr />

<p><a id="callback"/></p>

<h3><a href="#callback">Callback'и</a></h3>

<p>Слово <code>CALLBACK: ( "name" xt bytes -- )</code> принимает <code>xt</code> слова которое надо
оформить callback'ом и число <strong>байт</strong> которые будут использованы под параметры
на стеке при вызове. Совмещение формата вызова (cdecl,stdcall) целиком ложится
на вас.  При формате вызова cdecl (по умолчанию для C/C++) вы должны оставить на
стеке все входные параметры (продубировать перед использованием например). При
stdcall - <code>xt</code> должно снять все параметры. Также обратите внимание, что callback
должен всегда возвращать одно дополнительное значение - результат, даже если в
коде вызывающем callback-функцию она описана как void (это особенность работы
<code>CALLBACK:</code>).
Пример :</p>

<p>В cpp коде функция callback объявлена так :</p>

<pre><code>typedef void (*TestCallback)(char*,int);
</code></pre>

<p>форт-код callback'а</p>

<pre><code>:NONAME ( n str -- )
  2DUP \ дублируем параметры (т.к. cdecl)
  ASCIIZ&gt; CR TYPE \ строка
  CR . \ число
  0 \ возвращаемое значение
; 2 CELLS \ 2 параметра - 8 байт
CALLBACK: Test \ слово Test это callback
</code></pre>

<hr />

<p><a id="notfound"/></p>

<h3><a href="#notfound">Слово NOTFOUND</a></h3>

<p>Если во время цикла <code>INTERPRET</code> не будет
найдено очередное слово из входного потока - в текущем словаре ищется и
вызывается слово <code>NOTFOUND ( a u -- )</code>. Если <code>NOTFOUND</code> не обрабатывает данное
слово - он должен вывалиться с исключением. Иначе считается, что слово
воспринято и трансляция продолжается. По умолчанию через <code>NOTFOUND</code> реализовано
распознавание чисел и <a href="#doublecolon">доступ к вложенным словарям</a>.</p>

<p>Правило хорошего тона - при переопределении <code>NOTFOUND</code> сначала вызвать его
старый вариант, и если он не отвалится по исключению - выполнять свои
действия. Пример:</p>

<pre><code>: MY? ( a u -- ? ) S" !!" SEARCH &gt;R 2DROP R&gt; ;
: DO-MY ( a u -- ) ." My NOTFOUND: " TYPE CR ;

: NOTFOUND ( a u -- )
  2DUP 2&gt;R ['] NOTFOUND CATCH 
  IF
    2DROP
    2R@ MY? IF 2R@ DO-MY ELSE -2003 THROW THEN
  THEN
  RDROP RDROP
;
</code></pre>

<p>Или так:</p>

<pre><code>: NOTFOUND ( a u -- )
  2DUP MY? IF DO-MY EXIT THEN
  ( a u )
  NOTFOUND
;
</code></pre>

<p>Для подключения в цепочку <code>NOTFOUND</code>'ов удобно использовать расширение <code>~pinka/samples/2006/core/trans/nf-ext.f</code></p>

<hr />

<p><a id="scatcoln"/></p>

<h3><a href="#scatcoln">Scattered colons</a></h3>

<p>Расширяемые слова (описание техники: "<a href="http://www.forth.org.ru/~mlg/ScatColn/ScatteredColonDef.html">Scattering a Colon
Definition</a>", на английском языке). Позволяют уже после определения
слова добавлять в него новые действия. Слово <code>...</code> подготавливает место 
для будущего расширения. <code>..:</code> и <code>;..</code> добавляют действие как расширение.</p>

<pre><code>: INIT ... orig ; 
\ если вызвать INIT здесь то выполнится orig
..: INIT extend1 ;.. 
\ если здесь - то extend1 и orig именно в таком порядке
..: INIT extend2 ;.. 
\ эквивалентно : INIT extend1 extend2 orig ;
\ и так далее
</code></pre>

<p>Подобного эффекта можно добиться и с помощью векторов, но так намного удобнее.</p>

<p>Через scattered colons в SPF реализованы слова <code>AT-THREAD-STARTING</code> и
<code>AT-PROCESS-STARTING</code>, которые вызываются при старте потока и при старте
процесса соответственно. Например библиотека <code>lib/include/float2.f</code> добавляет в
<code>AT-THREAD-STARTING</code> действия по инициализации внутренних переменных.</p>

<hr />

<p><a id="doublecolon"/></p>

<h3><a href="#doublecolon">Область видимости</a></h3>

<p>Поиска слова во время интерпретации задаётся привычно стеком <code>CONTEXT</code>, но иногда
возникает необходимость явно указать из какого словаря брать слово. Для этого используется
синтаксис вида <code>Словарь::слово</code>. Пример:</p>

<pre><code>MODULE: someWords
: TYPE 2DROP ;
;MODULE

ALSO someWords \ добавляем словарь someWords в контекст
S" foo" TYPE \ ничего не выводится, берётся TYPE из someWords
S" bar" FORTH::TYPE \ явное указание "обычного" TYPE из главного словаря
</code></pre>

<p>Для выполнения неких действий над словами через <code>'</code> (взятие xt слова), <code>POSTPONE</code>
(компилирование), <code>TO</code> (для выполнения вторичного действия слова) область видимости 
нужно указывать следующим образом: </p>

<pre><code>Словарь::' word
Словарь::POSTPONE word
etc 
</code></pre>

<p>т.к. такие слова самостоятельно разбирают входной поток и <code>word</code> не попадает в <code>INTERPRET</code> 
и соответствующий <code>NOTFOUND</code>.</p>

<hr />

<p><a id="catch"/></p>

<h3><a href="#catch">Обработка исключений</a></h3>

<p>Обработка исключений в SPF происходит согласно ANS-94 с использованием <code>THROW</code> и <code>CATCH</code>.</p>

<p>Слово <code>THROW ( n -- )</code> выбрасывает исключение с кодом <code>n</code> (кроме случая когда <code>n</code> равен нулю), 
т.е. выполнение текущего слова прерывается и происходит возврат до тех пор пока исключение 
не будет поймано.</p>

<p>Слово <code>CATCH ( i*x xt -- i*x n | 0 )</code> выполняет <code>xt</code> и ловит исключения которые будут сгенерированы 
во время исполнения <code>xt</code>. Если исключений не было - на стеке ноль, в противном случае возвращается 
код исключения (тот <code>n</code> что был передан в слово <code>THROW</code> которое вызвало это исключение, или код
системной ошибки), при этом устанавливается глубина стека данных равной той что была до выполнения 
<code>xt</code> (но сами данные на стеке могут быть испорчены если <code>xt</code> писало в стек на этой глубине).</p>

<p>Все исключения делятся на два типа, по способу возникновения - системные (защита памяти, деление 
на ноль, etc) и родные (слово <code>THROW</code> с ненулевым параметром). Все они ловятся одинаково, но в 
случае системных дополнительно печатается отчёт об исключении.</p>

<p>Многие слова возвращают <code>ior</code> (код возврата ввода/вывода), например операции с 
файлами (<code>CREATE-FILE</code>, <code>OPEN-FILE</code>, <code>READ-FILE</code>, <code>WRITE-FILE</code>, <code>CLOSE-FILE</code> и т.д.)
и операции с памятью в куче (<code>ALLOCATE</code>, <code>FREE</code>, <code>RESIZE</code>). Этот ior соответствует коду 
ошибки (если таковая была) и его можно выбросить по <code>THROW</code>.</p>

<pre><code>: file S" rewdsadwerdfstrg" R/O OPEN-FILE THROW ; \ пытаемся открыть несуществующий файл
: divide 
    ['] / CATCH  \ ловим системное исключения от деления
    IF ." Dont divide by " . DROP  \ исключение произошло - на стеке два числа параметра
    ELSE ." Result : " . \ результат успешного выполнения
    THEN CR ; 
: test 
   10 2 divide \ всё ок
   1 0 divide  \ системное исключение - отчёт SPF и наше сообщение из слова divide
   ['] file CATCH IF ." Caught exception" CR THEN \ ловим родное исключение
   \ не обязательно выбрасывать ior, можно проанализировать его на месте
   S" dsderewfdstrtr" R/O OPEN-FILE IF ." bad file" ELSE ." Good file" THEN CR ;
test
</code></pre>

<p>Коды ошибок, которые принимаются словом <code>THROW</code> и оставляются словом <code>CATCH</code>,
интерпретируются согласно файлу <code>spf.err</code>, который находится в каталоге <code>lib</code>. Текстовые
сообщения которые печатаются в отчёте об исключении берутся из этого файла.</p>

<hr />
</td></tr></table></div></BODY></HTML>