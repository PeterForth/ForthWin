<HTML>
<HEAD>
 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
 <STYLE type="text/css">
body {background:white;}
* {font-family: arial, verdana, sans-serif}
code {font-family: 'Lucida Console', 'Courier New', monospace}
pre, code { background : #EEEEF4} </STYLE>
</HEAD>
<BODY>
<div align="center">
<table width="800">
<tr><td align="left">
<p><a id="start"/></p>

<h1>Устройство <a href="readme.ru.html">SPF</a></h1>

<p><title>Устройство SPF</title></p>

<p><i>Детали реализации ядра</i></p>

<p><small>Последнее обновление: $Date: 2008/08/26 19:07:51 $</small></p>

<!-- $Revision: 1.10 $ -->

<hr />

<p><!-- [<a href="src.en.html">Английский</a>] --> [<a href="src.ru.html">Русский</a>] </p>

<hr />

<h2>Содержание</h2>

<ul>
<li><a href="#regs">Распределение регистров</a></li>
<li><a href="#stack">Стеки</a></li>
<li><a href="#image">Хранилище</a></li>
<li><a href="#heap">Динамическая память</a></li>
<li><a href="#article">Словарная статья</a></li>
<li><a href="#make-kernel">Перекомпиляция ядра</a></li>
<li><a href="#macroopt">Макрооптимизатор</a></li>
<li><a href="#tovirt">>VIRT</a></li>
</ul>

<hr />

<p><a id="regs"/></p>

<h3><a href="#regs">Распределение регистров</a></h3>

<ul>
<li>EAX - вершина стека данных</li>
<li>EBP - указатель на стек данных (т.е. [EBP] - второй элемент стека данных)</li>
<li>ESP - указатель на стек возвратов</li>
<li>EDI - указатель на данные потока (указывает на начало USER-области текущего потока)</li>
</ul>

<hr />

<p><a id="stack"/></p>

<h3><a href="#stack">Стеки</a></h3>

<p>Стек возвратов совмещен с аппаратным стеком (ESP).
Стек параметров адресуется регистром EBP, вершина стека хранится в EAX</p>

<p>Указатели стеков: <code>SP@</code> <code>RP@</code> <code>SP!</code> <code>RP!</code></p>

<p>Дно стеков: <code>S0</code> <code>R0</code> </p>

<p>Оба стека начиная от своего дна, растут вниз (в сторону уменьшения адресов).</p>

<p>( <code>src/compiler/spf_translate.f</code> )</p>

<hr />

<p><a id="image"/></p>

<h3><a href="#image">Хранилище</a></h3>

<p>Контекст (<code>ORDER</code>, <code>CURRENT</code>) у каждого потока свой
(по умолчанию: <code>ONLY FORTH DEFINITIONS</code> ).
Поддерживается параллельная интерпретация.</p>

<p>Компиляция в одно хранилище должна осуществляться только одним потоком (во избежание).</p>

<p>Код и данные хранятся в едином хранилище (сегменте, кодофайле).
Слова доступа к нему стандартные : <code>HERE</code> <code>ALLOT</code> <code>,</code> <code>C,</code>
Слово <code>UNUSED</code> вынесено в <code>lib/include/core-ext.f</code></p>

<p><img src="images/src_static.png"/></p>

<p><code>IMAGE-BASE</code> - начало хранилища.</p>

<p><code>IMAGE-SIZE</code> - резервируемый размер.</p>

<p>Временные словари (  <code>TEMP-WORDLIST</code>  <code>FREE-WORDLIST</code> ).
Такой словарь ассоциирован с собственным хранилищем
(память для которого распределяется динамически).</p>

<p>Когда такой словарь (список) является текущим (<code>CURRENT</code>)
(словарем компиляции, целевым, в который добавляются слова)
<code>HERE</code> дает начало свободной области его хранилища.</p>

<hr />

<p><a id="heap"/></p>

<h3><a href="#heap">Динамическая память</a></h3>

<p><img src="images/src_heap.png"/></p>

<p><em>Windows:</em> У каждого потока свой хип. <code>ALLOCATE</code> выделяет память из хипа потока, в контексте 
которого вызвано. При завершении потока его хип уничтожается (вся память выделенная 
из этого хипа -- освобождается).</p>

<p><em>Linux:</em> Отдельных хипов нет. <strong>FIXME</strong> Надо ли синхронизировать ALLOCATE?</p>

<p>Хип процесса ядром форт-системы не используется.
(хотя в принципе, его можно использовать, и некоторые расширения делают это).</p>

<p><em>Windows:</em> При доступе к разделяемому хипу из разных потоков стоит вспомнить о необходимости синхронизации.</p>

<p>Кроме отдельной кучи каждый поток имеет свой собственный блок статических данных
-- USER-область (размером <code>EXTRA-MEM</code>, по-умолчанию 8кб). Переменные и массивы 
резервируются там словами словами <code>USER</code> , <code>USER-VALUE</code> .</p>

<hr />

<p><a id="article"/></p>

<h3><a href="#article">Словарная статья</a></h3>

<p>Словарь является односвязным списком с полем имени (его адрес обозначаемый как NFA 
используется для идентификации конкретной словарной статьи в словаре), полем кода 
в котором хранится <code>xt</code> действия данного слова, полем флагов (содержит признаки 
характеризующие это слово -- <code>&amp;IMMEDIATE</code> и <code>&amp;VOC</code> )</p>

<p><img src="images/src_voc.png"/></p>

<p>Т. н. "поля параметров" нет, так как "телом" определений в SPF являются последовательности
машинных инструкций.</p>

<p><strong>FIXME</strong> описание VOC-NAME! PAR! CLASS!</p>

<p>( <code>src/compiler/spf_wordlist.f</code> )</p>

<hr />

<p><a id="make-kernel"/></p>

<h3><a href="#make-kernel">Перекомпиляция ядра</a></h3>

<p><strong>FIXME</strong> перенести в intro</p>

<p>В файле <code>src/spf_compileoptions.f</code> описаны параметры компиляции по умолчанию которые можно 
переопределить в <code>src/compile.ini</code>.</p>

<p><em>Windows:</em> Компиляция ядра выполняется запуском bat-файла <code>src/compile.bat</code>. По умолчанию, 
сборку выполняет одна их младших версий SPF (<code>jpf375c.exe</code> в корневой папке), но
SPF может и сам собирать себя. 
Пререквизиты для сборки : </p>

<ul>
<li>исходники (<code>src</code> и <code>lib</code>) </li>
<li>целевой компилятор (например <a href="http://downloads.sourceforge.net/spf/JPF375C.EXE">jpf375c.exe</a>)</li>
</ul>

<p><em>Linux:</em> Для перекомпиляции ядра можно использовать <code>src/compile</code> или <code>src/Makefile</code>. Во время
сборки компилируется и выполняется программа на Си (<code>config.gen</code>) которая генерирует <code>src/posix/config.auto.f</code> с
определениями системно-зависимых констант. Целевой компилятор создаёт объектный файл, который потом
линкуется с системными библиотеками (libdl, libc, libpthread). В <code>src/compile.ini</code> необходимо вписать :</p>

<pre><code>TRUE TO TARGET-POSIX \ сборка для Linux
TRUE TO UNIX-ENVIRONMENT \ юниксовый EOLN
</code></pre>

<p>Пререквизиты для сборки :</p>

<ul>
<li>исходники (<code>src</code> и <code>lib</code>)</li>
<li>целевой компилятор (<code>spf4orig</code> (ранее собранный бинарник) либо <code>jpf375c.exe</code> под <a href="http://winehq.org/">wine</a>)</li>
<li>gcc (файлы include'ов, препроцессор, компилятор, линкер) <strong>FIXME</strong> точнее (имена пакетов)</li>
<li>src/compile.ini</li>
</ul>

<hr />

<p><a id="macroopt"/></p>

<h3><a href="#macroopt">Макрооптимизатор</a></h3>

<h4>Оптимизация основанная на шаблонах машинного кода</h4>

<p>Именно эти шаблоны и реакции на них составляют подавляющую часть 100 с лишним килобайт оптимизатора 
(файл <code>src/macroopt.f</code> ). Такая оптимизация на шаблонах в SPF4 заключается в том, что происходит 
подмена скомпилированного кода командой <code>OPT-RULES</code>. <code>OPT-RULES</code> содержит набор правил оптимизации,
представленных в виде программы. Каждое правило состоит из 2-х частей: идентификации кода и процедуры 
подмены. Доступ к коду осуществляется посредством массива ссылок на последние операторы <code>OP0</code>.
Использование <code>OP0</code> позволяет отделить коды команд от их операндов.</p>

<p>Правило замены фрагмента кода:</p>

<pre><code> NEG     EAX            \ F7 D8
 ADD     EAX , 0 [EBP]  \ 03 45 00
 NEG     EAX            \ F7 D8
</code></pre>

<p>на:</p>

<pre><code> SUB     EAX , 0 [EBP]  \  2B 45 00
</code></pre>

<p>Представляет собой:</p>

<pre><code> OP2 @  @  4503D8F7 XOR           \  NEG EAX  ADD EAX, X [EBP]
 OP0 @  W@ D8F7     XOR    OR 0=  \ NEG EAX
 IF  M\ 20 DTST
      OP1 @ @ 452B OR OP2 @ ! \  SUB EAX, X [EBP]
      OP2 ToOP0
      -4 ALLOT
      FALSE M\ 21 DTST
      EXIT
 THEN
</code></pre>

<h4>Подключение</h4>

<p>Во время компиляции ядра макрооптимизатор подключается два раза :</p>

<ul>
<li>в инструментальную систему, используется в процессе сборки для оптимизации кода целевой
(создаваемой) системы, подключается в <code>src/tc_spf.F</code> (USE-OPTIMIZER)</li>
<li>в целевую систему, для того чтобы новая система во время исполнения генерировала оптимизированный
код, подключается в <code>src/spf.f</code> (BUILD-OPTIMIZER)</li>
</ul>

<h4>Переменные из macroopt.f которые используются в ядре.</h4>

<p><code>OPT?</code> -- состояние оптимизатора: включён/выключен.</p>

<p><code>MM_SIZE</code> -- максимальный размер слова (в байтах) который позволено "разворачивать" 
("инлайнить") оптимизатору.</p>

<p><code>:-SET</code> -- устанавливает границу для оптимизатора, все команды находящиеся по адресам младшим 
значения <code>:-SET</code>, оптимизатор не трогает.</p>

<p><code>LAST-HERE</code> устанавливает адрес конца последней скомпилированной маш. инструкции. <code>LAST-HERE</code>
приравнивается в ядре <code>HERE</code> только по окончании каждой транзакции компиляции.</p>

<p><code>OP0</code>, <code>OP1</code>, ... <code>OP8</code> -- адреса 9-и последних скомпилированных машинных команд (<code>OP0</code> 
-- адрес начала самой последнего скомпилированной машинной инструкции, <code>OP1</code> -- адрес начала предпоследней 
инструкции, и т.д.).</p>

<p><code>JP0</code>, <code>JP1</code>, ... <code>JP4</code> -- адреса пяти последних скомпилированных машинных команд -- ветвлений 
(как условных так и безусловных).</p>

<hr />

<p><a id="tovirt"/></p>

<h3><a href="#tovirt">>VIRT</a></h3>

<p>Пользовательское пространство начинается под Windows 
с 0x500000, а под Линукс - гораздо дальше, в запрещенных для 
вин-программы адресах. Из-за этого приходится пересчитывать адреса при кросс-компиляции на Windows
объектного ELF файла для Linux. Если делать SPF/Linux под Линукс, то >VIRT не нужен.</p>

<hr />
</td></tr></table></div></BODY></HTML>