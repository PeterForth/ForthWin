<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link rel="stylesheet" href="forth2.css" type="text/css">
<title></title>
</head>

<body background="pic/grid.gif">

 <h1 class=lib><u>Дневник программиста</u>
 &nbsp;
 </h1>



<h2>14 марта 2005 года</h2>
<p>После успешного сочинения нормальной работы с закладками чувствую, что 
можно замахнуться на что-то большее и более сложное. Андрей Черезов еще 
год назад намекал, что в библиотеке хорошо бы выглядел разделитель окон, 
именуемый также на английский манер сплиттером. Тогда я же скачал с 
какого-то программистского сайта описание внутренностей этого самого 
сплиттера. В общем, он сводится к отдельному окну, которое можно тягать 
мышкой. Само тягание довольно сложно - надо обрабатывать множество 
сообщений мыши, причем учитывать состояние. Но это можно аккуратно 
переписать из сишного примера. Гораздо больше меня волнует другое - 
разделитель должен как-то управлять окружающими его окнами. В примере есть 
родительское окно, а у него два дочерних. Разделитель посылает сообщение 
родительскому окну, а то уже само меняет размер дочерних как считает 
нужным. Мне такая схема не годится, поскольку разделителей у меня может 
быть много и разбираться со своими окнами они должны сами - как в GTK. 
<h2>15 марта</h2>
<p>Засунуть разделитель в библиотеку WinCC или сделать отдельным файлом? 
После кратких колебаний решил вынести его отдельно. Библиотека и так 
немаленькая - размер исполняемого файла при подключении увеличивается 
килобайт на 150, что для Форта вообще непростительно. Впрочем. СП-Форт 
сознательно оптимизировался по скорости, а не по размеру памяти, в нем 
нет, например, шитого кода, так что мне не очень стыдно. 
<p>Разделитель должен управлять двумя сетками - так же, как закладка 
управляет одной своей сеткой. Для этого я уже ввел в объект "Элемент 
управления" кое-какую аппаратуру - как это сейчас модно выражаться, 
виртуальные функции <u>-ctlshow -ctlhide -ctlresize</u> и запрос на размер 
элемента. Не хватает, правда, <u>-ctlmove</u>. Надо бы добавить, а то набор 
получается неполный. 
<p>Упираемся в другой вопрос. По умолчанию сетка у меня упаковывается так, 
что места в ней нет вообще, соответственно разделителю двигаться тоже 
некуда. Долго думал и решил, что размера окна, задуманного программистом, 
я все равно не знаю, так что пусть сам увеличивает размер разделителя с 
дочерними сетками так, как надо. Мое дело - организовать сам разделитель. 
<h2>16 марта</h2>
<p>Разделитель должен выглядеть как обыкновенный элемент управления, с теми же самыми внутренними полями. Да это и есть элемент, только написанный не безымянными пролетариями из Редмонда, а мной самим.
<p>В общем, набрасываем. Разделитель ни на что не похож, поэтому расширим сразу control:
<code>
control table splitter-table
 item -isvertical
 item -grid1
 item -grid2
 item -ratio
end-table
</code>
В разделителе мы будем хранить флажок вертикальный/горизонтальный 
разделитель (чует мое сердце, что код будет почти одинаковый, но не 
настолько, чтобы вынести повторяющиеся части в отдельные слова), сами 
сетки и пропорцию - сколько в процентах ширины элемента занимает первая 
сетка. Ага, <u>-ratio!</u> должно перерисовывать разделитель, поэтому надо 
добавить 
<code>item -ratio get</code>
<h2>17 марта</h2>
Пришло время создавать окно элемента. Ограничимся пока вертикальным 
разделителем. Слово для создания элемента с заданной таблицей у меня есть. 
Вызываю 
<code>: vsplitter 
 splitter classname 0 create-control ;
</code>
<p>... И программа вылетает. Лезу в <u>create-control</u>, расставляю операторы 
печати (у меня старорежимная подготовка, и отладчиками я пользоваться так 
и не научился) и вижу, что сбоит слово <u>winresize</u>. После следующих опытов 
оказывается, что сбой происходит где-то в недрах системной функции 
<i>SetWindowPos</i>. Раньше я бы непременно нехорошо высказался о "Майкрософте" и 
ее методах писать программные продукты, но теперь я более грамотный и 
знаю, в чем фокус. Вышеупомянутая <i>SetWindowPos</i> при своем вызове посылает 
моему окну какое-то сообщение, обработчик которого и валится. Снова 
расставляю точки с буквой s и открываю, что обработчик слетает при вызове 
<u>thiswin -wndproc@ EXECUTE</u>. Вот она, горькая правда: никакого <u>-wndproc</u> у 
нового окна нет, а в соответствующей позиции лежит какой-то мусор. Ведь 
<u>-wndproc</u> относится только к стандартному окну - которое с рамочками и 
прочим, а само это свойство определено в таблице <u>window</u>. Настоящие
системные элементы сами разбираются со своими сообщениями и я их никогда 
не обрабатывал. 
<p>Но раз я уже собрался делать собственные элементы, то мне понадобится их 
обработка их сообщений по полной программе. Переставляю <u>-pre</u> и <u>-wndproc</u> из 
таблицы <u>windows</u> в таблицу <u>common</u>. 

<h2>18 марта</h2>
<p>Запускаем еще раз. И снова вылетаем. Куча точек, стандартный обработчик 
проходит нормально. Значит, вылетает уже какой-то конкретный обработчик. 
Постепенно выясняю, что это <i>wm_size</i>. И обнаруживаю полный набор: 
<u>-minustop@</u>, <u>-minusbottom@</u>, <u>-status@</u>, <u>-toolbar@</u> и даже <u>-grid@</u>. Естественно, 
ничего этого в моем элементе нет и быть не может. Положение сомнительное - 
вся стандартная обработка рассчитана на полноценное окно, а не на элемент. 

<p>В общем, нужен новый стандартный обработчик сообщений, рассчитанный на 
самопальные элементы - кое-какие общие части у них явно будут (установка 
размеров, раскраска). А старый пусть работает, как работал. 
<p>Как сделать новый обработчик? В традициях Windows завести отдельный 
класс окна, отвечающий за новую функциональность. Но нужно ли это мне? 
Новый класс надо отдельно регистрировать, что предполагает забивание 
огромных записей всякой маловразумительной ерундой. Нет, мой класс меня 
вполне устраивает. Усложню лучше немного стандартный обработчик и добавлю 
в таблицу <u>common</u> стандартное свойство <u>-messages</u>. Там будет храниться 
стандартный обработчик для этого окна - только не тот, что делается с 
помощью <u>MESSAGES;</u> то есть нормальная таблица обработчиков, а тот, что 
запрятан внутри библиотеки и называется <u>XLIST</u> - список таблиц 
обработчиков. Впрочем, этого все равно никто не заметит. 
<p><u>XLIST</u> в свое время я вводил на тот случай, если понадобится 
добавлять какие-то отдельные блоки обработчиков. Опыт показал, что это 
вещь совершенно ненужная. Вполне хватает функций пред-обработчика (<u>-pre@</u>) 
и пост-обработчика (<u>-wndproc</u>). 
<p>Пожалуй, <u>XLIST</u> стоит вообще выкинуть.
<h2>22 марта</h2>
<p>Ой нет, <u>XLIST</u> трогать нельзя. На этой функциональности завязана 
обработка всех вложенных меню, идентификаторы которых добавляются в 
основной список целыми таблицами. Лучше буду писать в <u>-messages</u> указатель 
на отдельный <u>XLIST</u>. 
<h2>23 марта</h2>
<p>Начал, наконец, подбираться к своей задаче. Добавил отдельный список 
сообщений специально для элементов и набросал сам разделитель. Поставил 
его в окно с помощью <u>place</u>. Работает. Добавил к моему разделителю свойство 
<u>-painter</u>, а в него поставил просто закраску черным цветом с помощью вызова 
<i>FillRect</i>, чтобы убедиться, что элемент действительно прорисовывается и 
визуально видеть его размеры. Действительно - в углу стоит маленький (20 
на 20) прямоугольничек. Ура! 
<p>Набросал специализированные вызовы <u>-ctlshow</u> и <u>-ctlhide</u>. Ничего сложного 
- показать обе сетки словом show-grid или, наоборот, спрятать. 
<p>Сделал <u>-ctlcalcsize</u>. Она должна запрашивать размер обоих сеток и 
возвращать размер элемента как (w1+w2, h1+h2). 
<p>Мой элемент рассчитан работать в рамках сетки, поэтому окружил и его 
сеткой, выставил ей автоматическую растяжку <u>-xspan -yspan</u>. 
<p>Запускаю снова - элемента на экране нет. Скорее к процедуре отрисовки, 
поставил там вывод звездочки. Звездочки нет. <u>-painter</u> вообще не 
вызывается. Очень любопытно. 
<h2>24 марта</h2>
<p>Полез смотреть все сообщения окну - в библиотеке есть соответствующее 
место, выводящее все сообщения. Раскомментировал его, скинул вывод в файл 
и стал созерцать. Выписал на бумажку номера сообщений, внимательно 
посмотрел - вызова <i>wm_paint</i> нет нигде. 
<p>Наверное, что-то не так с сеткой, родительское окно вовремя не вызывает 
мое. Убрал сетку, вернул на место  <u>place</u>. Отрисовки по-прежнему никакой. 
<p>В чем дело - непонятно.
<p>На всякий случай закомментировал запоминание в элементе всех его 
собственных функций - <u>ctlcalcsize</u>, <u>-ctlshow</u>, <u>-ctlhide</u>. Заработало. Снова в 
углу черный квадратик. 
<p>Значит, виновата одна из функций. Сообразил: <u>-ctlshow</u> показывает только 
сетки, но не показывает само окно. Добавил в него вызов <u>winshow</u>.  
<p>Начал рисовать сам разделитель - так, как написано в примере. Одна линия светлая, с другой стороны одна темная, другая еще темнее. Выходит красиво, только разделитель в восемь точек широковат. Поставил сначала шесть, а потом четыре. Вернул шесть - он симпатичнее.
<p>Полюбовался на красивый разделитель, аккуратно окруженный окнами, и вдруг заметил, что окна (сетки с многострочным полем ввода) сомнительно вытянуты по вертикали, хотя они должны по умолчанию быть размера 20 на 20 точек, то есть квадратные.
<p><u>-calcsize</u> явно работает неправильно. Он верно складывает ширину окон, а высоту их он складывать не должен (у меня окна сейчас стоят по горизонтали - я тестирую вертикальный разделитель), а должен определять максимальную высоту. Переделал. Окна правильные.
<p>Осталось самое сложное и неподступное - разделитель должен тягаться. В примере черт ногу сломит - какой-то захват мыши, обработка сообщений от мыши, перерисовка черты, изображающей положение разделителя, с помощью функции XOR. Как это все работает, представить себе не могу.
<p>Собрался идти спать, как заметил случайно, что в поля ввода невозможно ничего ввести. Курсор в них просто не становится. В чем дело, догадаться нетрудно - мой элемент висит сверху, занимает он все пространство вместе с дочерними сетками (в отличие от примера, где разделитель - только полоска между двумя настоящими окнами). Все сообщения приходят к нему, а он их никуда не пересылает.
<p>Что делать? Пересылать их дочерним окнам? Глупое занятие, мало ли, 
какие сообщения им нужны. Сделаю проще - отправлю свой элемент под самый 
низ, тогда окна в сетках окажутся сверху и сами будут забирать свои 
сообщения. Посмотрел, как поставить окно на низ, оказывается это можно 
совместить с показом окна. Выкинул из <u>-ctlshow</u> вызов <u>winshow</u> и заменил на 
хитрую системную функцию <i>SetWindowPos</i>. 
<p>Удовлетворенный, отправился спать.
<h2>29 марта</h2>
<p>Целый день прикидываю, как реализовать описанное в примере - оператор 
XOR, перерисовка два раза по одному месту, захват мыши. Пока ясно не 
представлю весь процесс, ничего писать не буду. 
<h2>30 марта</h2>
<p>Посмотрел, как разделитель сделан в The Bat! Никаких линий при перемещении 
там не рисуется, а двигается сам разделитель. Окна перерисовываются на 
ходу, а  не после отжатия кнопки мыши. Все современные разделители во всех 
программах, которые я припоминаю, сделаны именно так. Прикинул - это и 
реализовать будет гораздо проще. Можно обойтись без рисования линий. 
<h2>1 апреля</h2>
<p>Прикидываю - надо ведь еще менять курсор мыши. В примере это сделано через класс окна, а мне нужно будет отслеживать положение курсора и менять картинку при входе/выходе. При перетягивании этого делать не нужно. Похоже, нужно два режима - с нажатием кнопки и без него. 
<p>Еще надо где-то сохранять текущее положение разделителя, и его максимальный и минимальный ход. По текущему положению можно высчитать границы разделителя (самой полоски) и выставить нужный курсор.
<p>Очередная дилемма: в чем лучше хранить эти значения - в процентах или в точках. С одной стороны, точки легче использовать, с другой стороны - проценты тоже нужны, поскольку в любой момент сетка может быть масштабирована и значения в точках потеряют смысл.
<p>Решил хранить все-таки в точках, поскольку это значение требуется часто 
- при каждом движении мыши, а проценты - нечасто, только при 
масштабировании и если их спросит пользователь словом <u>-ratio@</u>. Точки 
должны пересчитываться из процентов только при изменении размеров 
элемента. 
<p>Поскольку вертикальный и горизонтальный разделители различаются только 
флажком <u>-isvert@</u>, перенес все работы по созданию внутренностей в отдельное 
слово <u>splitter-control</u>. 
<p>Заметил попутно, что если <u>create-control</u> не смог создать 
элемент, то на стеке у меня оставался мусор - ненужные уже сетки. 
<p>Попутно думаю: как бы не писать два куска одинакового кода для 
горизонтальных/вертикальных разделителей, а просто менять местами 
координаты, а дальше работать с одними и теми же переменными. 
<p>Заметил, что <u>-spmin@</u>, собственно,  всегда одинаковое - это минимальный 
размер первой сетки, следовательно, размер первой сетки можно отдельно 
воообще не хранить. 
<p><u>-spmax</u> = ширина элемента - минимальный размер второй сетки - 
ширина полоски разделителя. Это значение должен вычислять <u>remap-grids</u> - 
слово, вызываемое при перемещении или изменении размеров (<u>-ctlmove</u>, 
<u>-ctlresize</u>). <u>-spcur</u> должен вписывать он же. 
<p>Минимальный размер второй сетки запомнит и запишет <u>-calcsize</u>. Это 
размер сетки при первом вызове. Пусть его устанавливает сам программист, 
назначая нужные ему размеры элементов самостоятельно. 
<p>Начинаю подбираться к обработке движения мыши. Поставил 
<u>MESSAGES:</u>, добавил обработчик wm_mousemove и заставил его выводить 
координаты на экране. Координаты выглядят вполне разумно, отмеряются явно 
от начала моего элемента, приходят только тогда, когда курсор стоит в 
пределах окна элемента. 
<p>Узнать, попадает ли точка в заданный прямоугольник легко - есть 
системная функция <i>PtInRect</i>. С ней, правда, связана одна провокация, а 
вернее удар под дых. Проклятые сишники по-человечески ее написать не 
могли. Она определяется так:  
<code>
BOOL PtInRect(

    CONST RECT *lprc,	// address of structure with rectangle
    POINT pt 	// structure with point
   );
</code>
<p>Обратите внимание, что перед pt нету звездочки. Это означает, что в функцию реально надо передавать не адрес структуры, а значения ее элементов в обратном порядке! Слава богу, я с этим уже когда-то сталкивался. Тогда пришлось дизассемблировать код компилятора С. 
<p>Оказывается, что при любом движении курсора система тут же заменяет его на указанный в классе окна. Мне это только на руку - не нужно отслеживать, когда курсор выходит за границы элемента.
<p>Не забыть бы еще потом определить слово <u>set-ratio</u>, которое будет 
срабатывать при выражениях типа <u>50 sp -ratio!</u> и не только запоминать 
значение, но и переставлять сам разделитель. 
<h2>2 апреля</h2>
<p>Выкинул из <u>draw-splitter</u> расчет позиции полоски по процентам, 
хранящимся в <u>-ratio@</u>. Уже есть это значение в готовых точках (<u>-spcur@</u>) - 
пусть оттуда и берет. 
<p>Режим перемещения мыши будет храниться в переменной <u>-spdrag</u> (с нажатой 
кнопкой перетаскиваем разделитель, с отжатой - только включаем при 
необходимости наш курсор). 
<p>В захвате мыши, как оказалось, нет ничего сложного. После вызова 
<i>SetCapture</i> все сообщения мыши будут просто передаваться моему окну. При 
нажатии кнопки мыши включаем режим <u>-spdrag</u> и захватываем мышь. При отжатии 
- отпускаем мышь (<i>ReleaseCapture</i>). Единственная тонкость (почерпнутая в 
примере) - отключение режима <u>-spdrag</u> надо делать не при отпускании кнопки, 
а по приходе сообщения <i>wm_capturechanged</i>. Так нужно, потому что захват 
мыши может отключиться по каким-то другим причинам, не связанным с нашей 
программой, например, при открытии нового окна. Если мышь отпустили мы, то 
сообщение все равно придет - от функции <i>ReleaseCapture</i>.  
<h2>4 апреля</h2>
<p>Код какой-то не очень фортовский - куча локальных переменных и большие 
определения, которые делают все сразу. Поэтому вынес все пересчеты 
параметров в отдельные слова и упорядочил логику - кто должен 
пересчитывать размеры, кто масштабировать сетки, кто - перерисовывать 
окно. Избавил <u>remap-grids</u> от расчетов внутренних переменных вроде <u>-spcur@</u>. 
Это явно не его дело. 
<p>Начинаю отлаживать.
<p>Сразу слетает, но это ерунда - не указал окно при вызове 
<u>new-splitter-pos</u> 
<p>Начало зацикливаться. Оказывается, <u>new-splitter-pos</u> вызывает 
<u>recalc-splitter</u>, а тот, в свою очередь, <u>-ratio!</u>. <u>-ratio!</u> вызывает  
<u>new-splitter-pos-in-percents</u>, а тот - снова 
<u>new-splitter-pos</u>. Естественно,  
мне нужно просто запомнить новые проценты, а не передвигать указатель еще 
раз. Заменил <u>-ratio!</u> на <u>-ratio store</u>. 
<p>Теперь самое противное: перерисовка неправильная, хотя у меня стоит 
принудительная отрисовка элемента <u>force-redraw</u>. Элемент-то 
перерисовывается, а вот фон под ним - нет. 
<p>Думать уже не хочется, близок конец работы, мысли уже направляются 
постепенно на следующую задачу.  
<p>Модель отрисовки окон в Windows я так толком и не понял. <u>-painter</u> 
вызывается, как положено, перед ним три раза (!) вызывается <i>wm_erasebkgnd</i> 
родительского окна, вызов успешно отрабатывается, только фон окна как был 
грязный, так и остался. Не понимаю, как это вообще может быть. 
<p>Попутно во время скачек между файлами заметил ошибку в самой 
библиотеке:  процедура обработки <i>wm_erasebkgnd</i> устанавливается никому 
не нужный фоновый цвет вызовом <i>SetBkColor</i>. Это к вопросу об 
ортогональности системных фунций. Рисование прямоугольника берет цвет из 
контекста устройства, а рисование закрашенного прямоугольника использует 
отдельный аргумент. Очень остроумно.  
<p>Поставил вместо перерисовки элемента перерисовку родителя - все 
заработало. Не знаю, правильно ли это, наверное, не очень, но спросить не 
у кого, а в книгах только пишут "Запустите мастера". 
<p>Ура! Ура! Наконец, вертикальный разделитель работает, как ему и 
положено. Таскал его в разные стороны, увеличивал окно и радовался. 
<p>Потом поставил определения для горизонтального разделителя. Код 
получается почти идентичный, но вынести в отдельные слова ничего не 
получается, поскольку меняются местами не только сами значения, но и их 
порядок следования в вызове всех слов. 
<p>Горизонтальный разделитель тоже работает.
<h2>5 апреля</h2>
<p>Лежал утром в кровати и понял, что у меня неправильно выставляется 
<u>-ratio</u> при создании разделителя. Механически ставится 50 процентов, а 
должно высчитываться по минимальной длине обоих сеток. Переделал 
<u>-calcsize</u>. 
<p>Начал переписывать свои разрозненные заметки в более-менее 
упорядоченный дневник. Дошел до <u>force-redraw</u> и подумал, что сам элемент у 
меня прозрачный, а система считает, что он закроет все пространство. Нашел 
специальный стиль окна <i>ws_ex_transparent</i>, который должен уведомить, что 
окно прозрачное. Включил и вижу, что плевать на этот стиль хотели - 
по-прежнему фон не перерисовывается вообще. Вернул все на место. 

<h2>6 апреля</h2>
<p>Стал сочинять пример использования и добавил для красоты еще один 
разделитель. Запустил - все вылетает, а второй сетки на экране нет вообще. 
Расследование показало, что <u>child-win-rect</u> возвращает какие-то 
огромные координаты: 500 и выше. Продолжение расследования: координаты 
оказываются вполне правильными, но отмеряются они от начала экрана. 
Выясняется, что не установлено родительское окно для всех сеток, входящих 
в разделитель. В качестве исправления ввел для всех элементов 
дополнительное слово <u>-addpart</u>, которое должно будет добавить к родительскому окну все 
части элемента управления (сетки и отдельные элементы, если такие 
имеются).

<p>На этом работу над первой версией разделителя можно считать 
законченной. 

<h2>* * *</h2>
<p>Начинающие фортеры нередко жалуются, что SP-Forth под Windows труден и непонятен, 
научиться по нем очень сложно. Дело, наверное, не в Форт-системе, которая 
в общих чертах повторяет досовскую, а в сложности и нелогичности самой 
операционной системы, в которую собраны уже тысячи самых разных функций. 
Надеюсь, что мой дневник, описывающий создание небольшой, но вполне 
реальной библиотеки, поможет лучше понять логику ее работы. 
</body>
</html>
