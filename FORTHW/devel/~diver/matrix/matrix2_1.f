\ Работа с матрицами ver. 1.2
\ Якимов Д. А. 8.03.99 nsoft@chat.ru
\ Формат матрицы -      4 - указатель на область памяти с матрицей
\       Область памяти: 2 - столбцов
\                       2 - строк
\                       n - тело матрицы   
\ GET-ITEM пользуется переменной F-SIZE через FLOATS
\ размер исходной либы 4118 байт !!!

\ ver. 2.21 Калачев А. В. 9.10.2002
\ расширение библиотеки для работы с различными типами данных ( символы, слова, 
\ целые, флоаты), под это переделаны многие слова
\ добавлены: Транспонировать, СделатьТреугольной, ОпределительМатр, Минор,
\ ПрисоединеннаяМатр, Инициализировать_из_файла;
\ многопоточность;
\ пока размер 8800  байт - вполне не плохо

\ lib\include\float2.f
S" FLOAT-PAD" SFIND 0= [IF] 2DROP lib\include\float2.f [ELSE] DROP [THEN]

HERE
\ набор векторных слов, "спрятанных" под основными для унификации.
\ некоторые слова библиотеки были слегка изменены
USER-VECT запомнить	USER-VECT взять	\ операции с памятью
USER-VALUE смещение	USER-VECT смещение+	USER-VECT смещение*	\ "CELLсики"
USER-VECT дубль	USER-VECT бросить	USER-VECT обмен	USER-VECT вращать	USER-VECT над 	\ стековые операции
USER-VECT ноль	USER-VECT единица	\ числа, константы
USER-VECT разделить	USER-VECT умножить	USER-VECT сложить	\ арифметика
USER-VECT негатив
USER-VECT минимальный	USER-VECT максимальный	\ сравнения
USER-VECT равен?
USER-VECT печать	USER-VECT число?
\ ну, чем не рус. стиль :-)
\ хотя, если честно, хотедось бы подобрать альтернативу векторным словам
\ при сохранении унификации и не слишком большом росте размера либы,
\ а так просто скорость раза 2,5--3 меньше чем при обычных словах 

\ просто несколько маленьких слов в "довесок"
: 0 0 ;	: 1 1 ;	: 1* ;	\ : 8+ 8 + ;	: 8* 8 * ;
: >S ( addr n -- x true | false ) 0 0 2SWAP >NUMBER 
IF 2DROP DROP 0 ELSE DROP D>S -1 THEN ;
\ слова для управления/переключения текущего типа матриц, ранее созданные
\ матрицы свой тип не меняют, возможно тип матрицы будет указываться
\ в дополнительной ячейке после тела матрицы
: целые
['] ! TO запомнить	['] @ TO взять	\ операции с памятью
CELL TO смещение	['] CELL+ TO смещение+	['] CELLS TO смещение*	\ "CELLсики"
['] DUP TO дубль	['] DROP TO бросить	['] SWAP TO обмен	['] OVER TO над 	\ стековые операции
['] 0 TO ноль	 ['] 1 TO единица	\ числа, константы
['] / TO разделить	['] * TO умножить	['] + TO сложить	\ арифметика
['] NEGATE TO негатив	['] ROT TO вращать
['] MIN TO минимальный	['] MAX TO максимальный
['] = TO равен?
['] . TO печать		['] >S TO число?
; IMMEDIATE

: слова
целые 
['] W! TO запомнить	['] W@ TO взять	\ операции с памятью
2 TO смещение	['] 2+ TO смещение+	['] 2* TO смещение*	\ "CELLсики"
; IMMEDIATE

: байты
целые
['] C! TO запомнить	['] C@ TO взять	\ операции с памятью
1 TO смещение	['] 1+ TO смещение+	['] 1* TO смещение*	\ "CELLсики"
; IMMEDIATE

: флоаты
['] F! TO запомнить	['] F@ TO взять	\ операции с памятью
F-SIZE @ TO смещение	['] FLOAT+ TO смещение+	['] FLOATS TO смещение*	\ "CELLсики"
['] FDUP TO дубль	['] FDROP TO бросить	['] FSWAP TO обмен	['] FOVER TO над 	\ стековые операции
['] .e TO ноль	 ['] 1e TO единица	\ числа, константы
['] F/ TO разделить	['] F* TO умножить	['] F+ TO сложить	\ арифметика
['] FNEGATE TO негатив	['] FROT TO вращать
['] FMIN TO минимальный	['] FMAX TO максимальный
['] F= TO равен?
['] F. TO печать	['] >FLOAT TO число?
; IMMEDIATE


USER addr
: m,
addr @ запомнить смещение addr +!
;
\ создает матрицу в памяти, на входе ( строк столбцов )
: НеименМатр ( y x -- addr2 ) \ * 
    2DUP * смещение* CELL+ ALLOCATE THROW DUP
    >R W!                
    R@ 2+ W!
    R>                  
;
: Матрица ( row col -- ) \ * 
     CREATE HERE CELL+ , 2DUP W, W, * смещение* ALLOT 
     DOES> @ ( D: строка столбец -- F: r )
;
: Освободить  ( id -- ) 
     FREE THROW
;
: ВзятьПараметры ( id -- row col )
    DUP 2+ W@ SWAP W@
;
: ДатьПараметры ( row col id -- )
    DUP >R W!
    R> 2+ W!
;
: Формировать ( id -- ) 4 + addr ! ;
: Закончить ;
USER-VALUE Столбцов1
USER-VALUE Столбцов2
USER-VALUE Столбцов3
USER-VALUE Строк1
USER-VALUE Строк2
USER-VALUE Строк3
USER-VALUE РазмерМатр1
USER-VALUE РазмерМатр2
USER-VALUE РазмерМатр3
USER-VALUE НачалоМатр1
USER-VALUE НачалоМатр2
USER-VALUE НачалоМатр3

: ТекущаяМатр1 ( id -- )       \ *
    DUP ВзятьПараметры
    TO  Столбцов1
    TO  Строк1
    TO  НачалоМатр1
    Столбцов1 Строк1 * смещение* TO РазмерМатр1
;
: ТекущаяМатр2 ( id -- )       \ *
    DUP ВзятьПараметры
    TO  Столбцов2
    TO  Строк2
    TO  НачалоМатр2
    Столбцов2 Строк2 * смещение* TO РазмерМатр2
;
: ТекущаяМатр3 ( id -- )       \ *
    DUP ВзятьПараметры
    TO  Столбцов3
    TO  Строк3
    TO  НачалоМатр3
    Столбцов3 Строк3 * смещение* TO РазмерМатр3
;
: ИнформацияОМатр ( id -- )
    ТекущаяМатр1
    ." Строк: " Строк1 . CR
    ." Столбцов: " Столбцов1 . CR
    ." Начало: " НачалоМатр1 . CR
    ." Размер: " РазмерМатр1 . CR
;

\ в следующих словах число лежит на стеке, соответствующему типу данных
\ важно убедиться в соответствии типа числа и матрицы,
\ проще говоря - НЕ СПАТЬ!!! за клавиатурой

: Матр*Число ( id1 --   stack: r -- ) \ *
    ТекущаяМатр1
    НачалоМатр1 4 + DUP
    РазмерМатр1 + SWAP
    DO дубль I взять умножить \ FDUP F@ F*
       I запомнить \ F!
       смещение \ F-SIZE @
    +LOOP
    бросить \ FDROP
;
: Матр/Число ( id1 --  stack: r -- ) \ *
    ТекущаяМатр1
    НачалоМатр1 4 + DUP
    РазмерМатр1 + SWAP
    DO 
       I взять над разделить
       I запомнить \ F!
       смещение \ F-SIZE @
    +LOOP
    бросить
;

\ операции над матрицами различных типов _настоятельно_не_рекомендуются_
\ id1=id1+id2
: Матр+ ( id1 id2 -- )  \ *
    ТекущаяМатр2
    ТекущаяМатр1
    Столбцов1 Строк1 * 
    0 
    DO
     I смещение* НачалоМатр1 4 + + DUP >R взять \ F@  \ l addr F: r
     I смещение* НачалоМатр2 4 + + взять сложить R> запомнить \ F@ F+ F!
    LOOP
;
: GET-ITEM ( y x addr -- addr1 )  \ *
    >R
    SWAP     \ x y1
    R@ W@ * + смещение* \ FLOATS
    R> + 4 +
;
: ВзятьЭлемент ( y x addr -- )      \ *
    GET-ITEM  взять \ F@
;
: ДатьЭлемент ( y x addr F: r -- )   \ *
    GET-ITEM запомнить \ F!
;

USER-VALUE row USER-VALUE col \ вспомогательные переменные
: СтрокуНаСтолбец ( row col -- F: r ) \ *
    TO col TO row 
    ноль
    Столбцов1 0 
    DO
      I col НачалоМатр2 ВзятьЭлемент
      row I НачалоМатр1 ВзятьЭлемент
      умножить сложить \ F* F+
    LOOP
;
\ id3=id1*id2
: Матр* ( id1 id2 id3 -- ) \ *
    ТекущаяМатр3
    ТекущаяМатр2
    ТекущаяМатр1
    Строк1 Столбцов2 НачалоМатр3 ДатьПараметры
    Столбцов2 0
    DO 
      Строк1 0
      DO
         I J
         СтрокуНаСтолбец 
         I J НачалоМатр3 ДатьЭлемент
      LOOP
    LOOP
;
: ПечататьМатрицу ( id -- ) \ *
    ТекущаяМатр1
    Строк1 0
    DO
      Столбцов1 0
      DO
        J I НачалоМатр1 ВзятьЭлемент печать ( F. ) SPACE
      LOOP
      CR
    LOOP
;
\ id1 -> id2
: КопироватьМатр ( id1 id2 -- ) \ *
    ТекущаяМатр2
    ТекущаяМатр1
    НачалоМатр1 НачалоМатр2 Строк1 Столбцов1 * смещение* 4 +
    CMOVE
;
: Инициализировать ( id F: r -- )  \ *
    ТекущаяМатр1
    Столбцов1 0 
    DO
      Строк1 0 
      DO
        дубль I J НачалоМатр1 ДатьЭлемент 
      LOOP
    LOOP
    бросить
;
: СделатьЕдиничной ( id -- ) \ *
    >R ноль R@ Инициализировать
    R> ТекущаяМатр1
    Столбцов1 0
    DO
      единица I DUP НачалоМатр1 ДатьЭлемент
    LOOP
;
: ИскатьМин ( id-matr -- F: r )  \ *
      ТекущаяМатр1
      0 0 НачалоМатр1 ВзятьЭлемент
      Столбцов1 0
      DO
        Строк1 0
        DO
          I J НачалоМатр1 ВзятьЭлемент
          минимальный \ FMIN
        LOOP
      LOOP
;
: ИскатьМакс ( id-matr -- F: r ) \ *
      ТекущаяМатр1
      0 0 НачалоМатр1 ВзятьЭлемент
      Столбцов1 0
      DO
        Строк1 0
        DO
          I J НачалоМатр1 ВзятьЭлемент
          максимальный \ FMAX
        LOOP
      LOOP
;
: НоваяМатр ( id -- addr )
        ВзятьПараметры НеименМатр 
;
: ЕденицыНадДиагональю ( id -- )
  >R ноль R@ Инициализировать
  R> ТекущаяМатр1
    Столбцов1 1 = IF EXIT 
                  ELSE Строк1 1 = IF EXIT THEN
                  THEN
    Столбцов1 1- 0
    DO
      единица I DUP 1+ НачалоМатр1 ДатьЭлемент
    LOOP
;
    
USER-VALUE Временная
\ матр id в степени u
: Матр** ( id u -- ) \ *
    DUP 1 >
    IF
      OVER DUP ВзятьПараметры НеименМатр TO Временная
      TO НачалоМатр1
      1 DO
          DUP НачалоМатр1 Временная Матр*
          Временная TO НачалоМатр1
        LOOP
      Временная SWAP КопироватьМатр
      Временная Освободить 
    ELSE 2DROP
    THEN
;
: Транспонировать ( id -- idT ) \ возвращает id новой, транспонированной матрицы
DUP ТекущаяМатр1 НоваяМатр ТекущаяМатр2
НачалоМатр1 ВзятьПараметры SWAP НачалоМатр2 ДатьПараметры
Строк1 0 DO
 Столбцов2 0 DO
   J I НачалоМатр1 ВзятьЭлемент
   I J НачалоМатр2 ДатьЭлемент
 LOOP
LOOP
НачалоМатр2
;

USER-VALUE K
USER-CREATE mn1 16 USER-ALLOT
: СделатьТреугольной ( id -- ) \ версия 2.3
ТекущаяМатр1 единица mn1 запомнить
Строк1 1- 0 ?DO
 Строк1 1- I ?DO I TO K 
I I НачалоМатр1 ВзятьЭлемент \ множ1
\ небольшая корректировка: определитель полученной матрицы будет
\ в множ1_1*множ1_2*... раз больше своего искомого значения, попытаемся это устранить
дубль ноль равен? IF бросить
\ искать_не_нулевой -- возвращает номер строки с ненулевым итым элементом
   0
   Строк1 I 1+ DO
    DROP
    I J НачалоМатр1 ВзятьЭлемент
    ноль равен? IF 0 ELSE I LEAVE THEN
   LOOP
  DUP TO row IF \ i <-номер строки с ненулевым итым элементом 0 - если эстальные эл-ты столбца нулевые
  I TO col \  I ." row=1-найденный col=2-текущий "
    \ поменять_строки 1 & 2
    Столбцов1 0 DO
      col I НачалоМатр1 ВзятьЭлемент
      row I НачалоМатр1 ВзятьЭлемент
      col I НачалоМатр1 ДатьЭлемент
      row I НачалоМатр1 ДатьЭлемент
    LOOP
   mn1 взять негатив mn1 запомнить
   \ т.к. при перестановке строк определитель меняет знак
    I I НачалоМатр1 ВзятьЭлемент
  ELSE LEAVE \ выход из цикла, переход на след. строку
  THEN
THEN
 Строк1 1- I ?DO
 I 1+ J НачалоМатр1 ВзятьЭлемент 
 дубль ноль равен? INVERT IF негатив \ множ2
 над mn1 взять умножить mn1 запомнить
   Столбцов1 J DO	\ 1 2
     дубль 
     K I НачалоМатр1 ВзятьЭлемент
     умножить	        \ 1 2 3
     вращать дубль	\ 2 3 1 1
     J 1+ I НачалоМатр1 ВзятьЭлемент
     умножить вращать	\ 2 3 1 4 -- 2 1 4 3
     сложить
     J 1+ I НачалоМатр1 ДатьЭлемент
     обмен
   LOOP \ бросить
   THEN бросить
   LOOP бросить
 LOOP 
LOOP
;
: ОпределительМатр ( id --   stack: -- опред)
\ стек - для целых обычный, для флоатов стек сопроцессора
единица mn1 запомнить
DUP НоваяМатр DUP ТекущаяМатр2
КопироватьМатр
НачалоМатр2 СделатьТреугольной
единица
НачалоМатр2 ВзятьПараметры DROP 0 DO
  I DUP НачалоМатр2 ВзятьЭлемент умножить
LOOP 
НачалоМатр2 Освободить
mn1 взять разделить
;
: Минор ( строка_i столбец_j id id2 --   stack:  -- minor ) \ точнее возвращается определитель минора
ТекущаяМатр2 \ вспомогательная матрица для минора уже сформирована ранее
ТекущаяМатр1 \ исходная матрица
TO col TO row
НачалоМатр2 4 + TO Временная \ ." адрес начала тела матрицы минора "
Строк1 0 DO
  Столбцов1 0 DO
   J I 2DUP col = SWAP row = OR \ ." элементы i строки и j столбца не берем"
    IF 2DROP
    ELSE
     НачалоМатр1 ВзятьЭлемент
     Временная запомнить Временная смещение+ TO Временная
    THEN
  LOOP
LOOP \ ." сформировали матрицу минора, найдем его определитель "
НачалоМатр2 ОпределительМатр \ считаем алг. дополнение
;
: ПрисоединеннаяМатр ( id -- id* ) \ возвращает id присодиненной матрицы
DUP НоваяМатр ТекущаяМатр3 \ ." 1- исходная "
DUP ВзятьПараметры 1- SWAP 1- SWAP НеименМатр \ ." 1 2- вспомогательная "
Строк3 0 DO
  Столбцов3 0 DO
   J I 2OVER Минор FABORT 
   I J + 2 MOD IF негатив THEN \ -1^(i+j)
   I J НачалоМатр3 ДатьЭлемент
  LOOP 
LOOP Освободить DROP
НачалоМатр3
;
: ОбратнаяМатр ( id -- id^-1 ) \ возвращает id матрицы, обратной данной
\ скорее всего только для флоатов
DUP ПрисоединеннаяМатр >R ОпределительМатр R@ Матр/Число R>
;
: Инициализировать_из_Файла ( addr n id -- )
ТекущаяМатр1 R/O OPEN-FILE THROW DUP \ файл файл 
DUP FILE-SIZE THROW  
DROP DUP ALLOCATE THROW              \ файл файл размер адрес
DUP TO Временная SWAP ROT            \ файл адрес размер файл
2SWAP 2OVER                          \ размер файл файл адрес размер файл
READ-FILE THROW 2DROP                \ размер файл
Временная ROT                        \ файл адрес размер
SOURCE 2>R
SOURCE!                              \ установили входной поток на наш файл
Строк1 0 DO
  Столбцов1 0 DO
    NextWord 
    число?          \ файл addr n - возможно это число
                    \ на стеке флаг на stack: число, если это оно
      IF
      J I НачалоМатр1 ДатьЭлемент
      ELSE ABORT" неправильный формат числа или что там ещё???" 
      THEN
  LOOP
LOOP
CLOSE-FILE THROW \ Временная FREE THROW
2R> SOURCE! EXIT REFILL DROP \ Временная FREE THROW
;

\ STARTLOG
HERE SWAP - 
CR .( MATRIX            V2.22          09 October  2002   --  ) . .( bytes) 

(
Нужна была библиотека работы с матрицами - она перед вами.
Это настоящий шедевр.
Объект - указатель на область памяти матрицы.
Пример использования - в скобках.
Обратите внимание на реализацию процедуры умножения - можно пользоваться 
вспомогательными матрицами любого размера.
С матрицами можно делать все что душе Вашей угодно, даже возводить в 
степень. Этот файл - наглядный пример преимущества ФОРТа над с++
(взгляните на его размер и имена операторов - в с++ об этом можно было 
только мечтать
Чрезвычайная удобство в отладке и пр.
Кто пользуется - напишите впечатления, пожелания, предложения...

ver 1.1 - переделано Инициализировать
ver 1.2 - добавлены ИскатьМин и ИскатьМакс
)
